<!doctype html>
<!-- TODO When you add script to app, change **** line down below -->
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
    <title>Channels</title>
    <style>
      body {
        font-size: 20px;
        margin: 0
      }
      .dark {
       background-color: black 
      }
      main {
        margin: 0 auto;
        max-width: 700px;
        padding: 0 10px 70px;
        position: relative;
        z-index: 1
      }
      h1, p {
        text-align: center
      }
      #search {
        -webkit-appearance: none;
        -webkit-border-radius:0;
        border: solid #000 1px;
        border-radius:0;
        font-family: serif;
        font-size: 20px;
        padding: 6px;
        width: 175px
      }
      #search::placeholder {
        font-family: serif;
        font-size: 20px
      }
      input[type="search"]::-webkit-search-cancel-button {
        -webkit-appearance: none;
        background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAn0lEQVR42u3UMQrDMBBEUZ9WfQqDmm22EaTyjRMHAlM5K+Y7lb0wnUZPIKHlnutOa+25Z4D++MRBX98MD1V/trSppLKHqj9TTBWKcoUqffbUcbBBEhTjBOV4ja4l4OIAZThEOV6jHO8ARXD+gPPvKMABinGOrnu6gTNUawrcQKNCAQ7QeTxORzle3+sDfjJpPCqhJh7GixZq4rHcc9l5A9qZ+WeBhgEuAAAAAElFTkSuQmCC);
        background-repeat: no-repeat;
        background-size: 20px;
        cursor: pointer;
        display: block;
        height: 20px;
        width: 20px
      }
      fieldset {
        border: 0;
        margin: 1em 0;
        padding: 0;
        text-align: center
      }
      legend, input[type="radio"] {
        border: 0;
        clip: rect(1px, 1px, 1px, 1px);
        height: 1px;
        margin: -1px;
        overflow: hidden;
        padding: 0;
        position: absolute;
        width: 1px;
      }
      input[type="radio"]:checked + label {
        text-decoration: underline
      }
      #filter label {
        cursor: pointer
      }
      #filter label:last-child {
        margin-left: 20px
      }
      table {
        border-collapse: collapse;
        border-spacing: 0px;
        margin: 0 auto
      }
      td {
        border: 1px solid black;
        height: 36px;
        padding: 5px 12px
      }
      td {
        cursor: pointer
      }
      td a {
        text-decoration: none
      }
      .favorite, .channel {
        text-align: center;
        width: 30px
      }
      .search-item {
        padding: 5px 20px
      }
      nav {
        background-color: #000;
        bottom: 0;
        color: white;
        position: fixed;
        text-align: center;
        width: 100%;
        z-index: 1
      }
      nav ul {
        font-size: 0; /* no space between nav items */
        margin: 0 auto;
        max-width: 700px;
        padding: 0
      }
      nav li {
        border-right: 1px solid #fff;
        display: inline-block;
        font-size: 20px;
        list-style-type: none;
        margin: 0;
        padding: 10px 0;
        width: 45%
      }
      nav li:last-child {
        border: 0
      }
      nav a {
        color: #fff;
        display: inline-block;
        width: 100%
      }
      nav a:hover {
        color: red
      }
      .hide {
        display: none
      }
      .embed-container {
        height: 0;
        padding-bottom: 56.25%;
        position: relative
      }
      .embed-container iframe {
        height: 100%;
        left: 0;
        position: absolute;
        top: 0;
        width: 100%
      }
      #overlay {
        padding-bottome: 0;
        background-color: black /* rgba(0,0,0,0.9);
        bottom: 0;
        height: 100%;
        left: 0;
        padding: 10px;
        position: fixed;
        right: 0;
        top: 0;
        width: calc(100% - 20px);
        z-index: 2 
        */
      }
      #overlay h1 {
        color: white;
        font-size: 1.5em;
        margin: .83em 0
      }
      #close {
        background-color: black;
        border: 2px solid white;
        color: #fff;
        font: 20px serif;
        line-height: 2.5;
        margin-top: 30px;
        padding: 0 20px
      }
    </style>
  </head>
  <body>
    <main>
      <h1>Channels</h1>
      <p>
        <label for="search">Search:</label>
        <input aria-label="Search channels" id="search" name="search" placeholder="Dane, Kelly, etc." type="search">
      </p>
      <fieldset id="filter">
        <legend>Filter</legend>
        <input id="all" name="filter" tabindex="-1" type="radio" value="all">
        <label for="all" tabindex="0">All Channels</label>
        <input id="favorites" name="filter" tabindex="-1" type="radio" value="favorites">
        <label for="favorites" tabindex="0">Favorite Channels</label>
      </fieldset>
      <table>
        <tbody>
          <tr class="all">
            <td aria-label="Favorite channel" aria-pressed="false" class="favorite" id="Channel1" role="button" tabindex="0">♡</td>
            <td class="channel">
              <a href="dane-reynolds">1</a>
            </td>
            <td class="search-item">
              <a href="dane-reynolds">Dane Reynolds</a>
            </td>
          </tr>
          <tr class="all">
            <td aria-label="Favorite channel" aria-pressed="false" class="favorite" id="Channel2" role="button" tabindex="0">♡</td>
            <td class="channel">
              <a href="kelly/index.html">2</a>
            </td>
            <td class="search-item">
              <a href="kelly/index.html">Kelly Slater</a>
            </td>
          </tr>
          <tr class="all">
            <td aria-label="Favorite channel" aria-pressed="false" class="favorite" id="Channel3" role="button" tabindex="0">♡</td>
            <td class="channel">
              <a href="channel/craig.html">3</a>
            </td>
            <td class="search-item">
              <a href="channel/craig.html">Craig Anderson</a>
            </td>
          </tr>
        </tbody>
      </table>
      <p class="hide" id="empty-query">No channels exist that match your query.</p>
      <p class="hide" id="empty-filter">No favorite channels have been selected.</p>
    </main>
    <main id="overlay" hidden>
      <h1>Dane Reynolds Channel</h1>
      <div class="embed-container">
        <div id="player1"></div>
        <div id="player2"></div>
        <div id="player3"></div>
      </div>
      <p>
        <button id="close">Close Channel</button>
      </p>
    </main>
    <nav>
      <ul>
        <li>Channels</li>
        <li>
          <a href="movies.html">Movies</a>
        </li>
      </ul>
    </nav>

    <script>

      // This code loads the iframe Player API code asynchronously (only need this once)
      var tag = document.createElement('script');
      tag.src = "https://www.youtube.com/iframe_api";
      var firstScriptTag = document.getElementsByTagName('script')[0];
      firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);


      var playerInfoList = [{
        id: 'player1',
        list: 'PLMxOsrgGH8n5HGL-UjsVoRQnemeWRcwkx',
        length: 62
      }, {
        id: 'player2',
        list: 'PLMxOsrgGH8n49WElPVU1isa7ifuUkZFMf',
        length: 5
      }, {
        id: 'player3',
        list: 'PLMxOsrgGH8n622jc8CpXksExjvI0z6Cxy',
        length: 1
      }];
      var players = new Array();
      function onYouTubeIframeAPIReady() {
        if (typeof playerInfoList === 'undefined') return;
        for (var y = 0; y < playerInfoList.length; y++) {
          var currentPlayer = createPlayer(playerInfoList[y]);
          players[y] = currentPlayer;
        }
      }
      function createPlayer(playerInfo) {
        return new YT.Player(playerInfo.id, {
          height: '100%',
          width: '100%',
          events: {
            'onReady': onPlayerReady,
            //'onStateChange': onPlayerStateChange
          }
        });
      }
      function onPlayerReady(event) {
        //get player details -> console.log(event.target);
        //hide player document.getElementById('player1').setAttribute('hidden', '');
        // Loop through all of the players
        for (var z = 0; z < playerInfoList.length; z++) {
          // Check if there is a playlist in local storage
          if (localStorage.getItem(playerInfoList[z].id+'Playlist') != null) {
            playerInfoList[z].id.cuePlaylist(
              localStorage.getItem(playerInfoList[z].id+'Playlist'),
              localStorage.getItem(playerInfoList[z].id+'Index'),
              localStorage.getItem(playerInfoList[z].id+'Time')
            );
            playerInfoList[z].id.setLoop(true);
          }
          else {
            // Random number decides which video will play first in the playlist
            var vid = Math.floor((Math.random() * playerInfoList[z].length) + 1);
            var player = playerInfoList[z].id;
            var list = playerInfoList[z].list;
            player.cuePlaylist({
              listType:'playlist',
              list:list,
              index:vid
            });
            //A second after the player is ready, it is set to shuffle all of the videos in the playlist. It is also set to loop the playlist.
            setTimeout(function() {
              event.target.setShuffle({'shufflePlaylist' : true});
            }, 1000);
            player1.setLoop(true); 
          }
        }
      }


      function onPlayer1StateChange(event) {
        if (event.data === 2) {
          localStorage.setItem('Player1Playlist', player1.getPlaylist());
          localStorage.setItem('Player1PlaylistIndex', player1.getPlaylistIndex());
          var obj = player1.getVideoData();
          localStorage.setItem('Player1VideoID', obj[Object.keys(obj)[0]]);
          localStorage.setItem('Player1Time', player1.getCurrentTime());
        }
      }

      // Variables for counters and determining empty fields
      var a, b, c, d, e, f, g, h;
      const EMPTY = '';

      // Variables for all of the components
      const ALLLABEL = document.querySelector('label[for=all]');
      const CHANNELNAMES = document.querySelectorAll('.search-item');
      const CHANNELNUMBERS = document.querySelectorAll('.channel');
      const EMPTYFILTER = document.getElementById('empty-filter');
      const FAVORITELABEL = document.querySelector('label[for=favorites]');
      const FAVORITES = document.querySelectorAll('.favorite');
      const MAIN = document.querySelector('main');
      const SEARCH = document.querySelector('#search');
      const TABLE = document.querySelector('table');
      var filters = document.querySelectorAll('input[name=filter]');


      const BODY = document.querySelector('body');
      const NAV = document.querySelector('nav');
      const OVERLAY = document.getElementById('overlay');
      const CLOSE = document.getElementById('close');
      const D = document.querySelectorAll('a[href=dane-reynolds]');
      CLOSE.addEventListener('click', close);
      const TITLE = 'Channels';
      /*
      D.addEventListener('click', function(e){
        e.preventDefault();
        var data = e.target.getAttribute('id'),
          url = data + '/';
        history.pushState(data, null, url);
        OVERLAY.removeAttribute('class');
        player.playVideo();
        document.title = 'Dane Reynolds Channel';
        e.stopPropagation();
      }, false);
      */
      for (x = 0; x < D.length; x++) {
        D[x].addEventListener('click', daneClick, false);
      }
      function daneClick(e) {
        e.preventDefault();
        player1.playVideo();
        var data = e.target.getAttribute('href'),
          url = data + '/';
        history.pushState(data, null, url);
        MAIN.setAttribute('hidden', '');
        BODY.setAttribute('class', 'dark');
        NAV.setAttribute('class', 'hide');
        OVERLAY.removeAttribute('hidden');
        document.title = 'Dane Reynolds Channel';
        e.stopPropagation();
      }
      window.addEventListener('popstate', function(e){
        var ch = e.state;
        if (ch == null) {
          player1.pauseVideo();
          MAIN.removeAttribute('hidden');
          BODY.removeAttribute('class');
          NAV.removeAttribute('class');
          OVERLAY.setAttribute('hidden', '');
          document.title = TITLE;
        } else {
          MAIN.setAttribute('hidden', '');
          BODY.setAttribute('class', 'dark');
          NAV.setAttribute('class', 'hide');
          OVERLAY.removeAttribute('hidden');
          player1.playVideo();
          document.title = 'Dane Reynolds Channel';
        }
      });


      function init() {

        // Initiate and populate local storage if there isn't any
        // Otherwise set up page with saved components
        if (localStorage.length === 0) {
          populateChannelStorage();
          populateFilterStorage();
          populateSearchStorage();
        } else {
          setChannelStyles();
          setFilterStyles();
          setSearchValue();
        }

        // If user left anything in the search field, run the search function
        if (SEARCH.value !== EMPTY) {
          search();
        }

        // Add event listeners - search, table cell, filter, and label interactions
        SEARCH.addEventListener('keyup', search);
        SEARCH.addEventListener('search', search);
        for (a = 0; a < CHANNELNAMES.length; a++) {
          FAVORITES[a].addEventListener('click', toggleButtonClickHandler);
          FAVORITES[a].addEventListener('keydown', toggleButtonKeydownHandler);
          FAVORITES[a].addEventListener('keyup', toggleButtonKeyupHandler);
          CHANNELNUMBERS[a].addEventListener('click', tdClick);
          CHANNELNAMES[a].addEventListener('click', tdClick);
        }
        for (b = 0; b < filters.length; b++){
          filters[b].addEventListener('click', filterClick);
        }
        ALLLABEL.addEventListener('keydown', toggleFilterKeydownHandler);
        ALLLABEL.addEventListener('keyup', toggleButtonKeyupHandler);
        FAVORITELABEL.addEventListener('keydown', toggleFilterKeydownHandler);
        FAVORITELABEL.addEventListener('keyup', toggleButtonKeyupHandler);

      } // end init


      function close() {
        player1.pauseVideo();
        BODY.removeAttribute('class');
        MAIN.removeAttribute('hidden');
        NAV.removeAttribute('class');
        OVERLAY.setAttribute('hidden', '');
        var pathArray = window.location.pathname.split('/');
        var fullURL = window.location.protocol + "//" + window.location.host;
        for (i = 0; i < 3; i++) {
          fullURL += pathArray[i];
          fullURL += "/";
        }
        history.pushState(null, null, fullURL);
        document.title = TITLE;
      }


      /**
       * Runs when user interacts with the channel filter (by click or keyboard).
       * Filter the page contents according to the incoming channel filter.
       * Populate filter in local storage.
       *
       * @param {KeyboardEvent} event
       */
      function filterClick(event) {
        if (this.value === 'favorites' || event.htmlFor === 'favorites') {
          filters[0].removeAttribute('checked');
          filters[1].setAttribute('checked', '');
          filters[1].checked = true;
          populateFilterStorage();
          filterFavorites();
        }
        else {
          filters[0].setAttribute('checked', '');
          filters[0].checked = true;
          ALLLABEL.focus();
          filters[1].removeAttribute('checked');
          populateFilterStorage();
          EMPTYFILTER.classList.add('hide');
          TABLE.removeAttribute('class');
          var tr = document.getElementsByTagName('tr');
          for (c = 0; c < tr.length; c++) {
            tr[c].classList.remove('hide');
          }
        }
      }

      /**
       * When filter is set to favorite channels, focus on the filter, hide rows
       * with the all channels filter.
       *
       * If no favorites are selected, hide the whole table and show the empty
       * filter paragraph.
       */
      function filterFavorites() {
        FAVORITELABEL.focus();
        var allOnlyRows = document.querySelectorAll('.all');
        for (d = 0; d < allOnlyRows.length; d++) {
          allOnlyRows[d].classList.add('hide');
        }
        if (allOnlyRows.length === 3) { // **** change this number to the number of channels
          TABLE.classList.add('hide');
          EMPTYFILTER.removeAttribute('class');
        }
      }

      /**
       * Populate local storage with the id of the channel when the favorite
       * icon is pressed. Also save whether the icon is pressed and the channel filter.
       * Set the channel styles on their respective componets.
       */
      function populateChannelStorage() {
        for (e = 0; e < FAVORITES.length; e++) {
          localStorage.setItem(FAVORITES[e].id, FAVORITES[e].innerText);
          localStorage.setItem(FAVORITES[e].id+'Pressed', FAVORITES[e].getAttribute('aria-pressed'));
          localStorage.setItem(FAVORITES[e].id+'Filter', FAVORITES[e].parentElement.classList);
        }
        setChannelStyles();
      }

      /**
       * If no filter is checked (likely on user's first visit), set the filter to all channels.
       * Populate local storage with the channel filter that is selected.
       */
      function populateFilterStorage() {
        if (filters[0].checked === false && filters[1].checked === false){
          filters[0].setAttribute('checked', '');
        }
        for (f = 0; f < filters.length; f++){
          if (filters[f].checked) {
            localStorage.setItem('FilterSelected', filters[f].value);
          }
        }
        setFilterStyles();
      }

      /**
       * Populate local storage with the value that is in the search field.
       * Sets the search field value to the value that is saved in the local storage.
       */
      function populateSearchStorage() {
        localStorage.setItem('SearchValue', SEARCH.value);
        setSearchValue();
      }

      /**
       * Sets the styles of all the channels based on their values in local storage.
       */
      function setChannelStyles() {
        var channelIcons = [];
        var rowFilters = [];
        var arias = [];
        for (g = 0; g < FAVORITES.length; g++) {
          channelIcons[g] = localStorage.getItem(FAVORITES[g].id);
          rowFilters[g] = localStorage.getItem(FAVORITES[g].id+'Filter');
          arias[g] = localStorage.getItem(FAVORITES[g].id+'Pressed');
          FAVORITES[g].innerText = channelIcons[g];
          FAVORITES[g].parentElement.classList = rowFilters[g];
          FAVORITES[g].setAttribute('aria-pressed', arias[g]);
        }
      }

      /**
       * Sets the style of the filter based on the values saved in local storage.
       * If the filter is set to favorite channels, displays the favorite channels.
       */
      function setFilterStyles() {
        var filterChecked;
        filterChecked = localStorage.getItem('FilterSelected');
        if (filterChecked === 'all') {
          filters[0].checked = true;
          filters[0].setAttribute('checked', '');
        }
        else {
          filters[1].checked = true;
          filters[1].setAttribute('checked', '');
          filterFavorites();
        }
      }

      /**
       * Sets the search field value to the value that is saved in the local storage.
       */
      function setSearchValue() {
        var savedSearch = localStorage.getItem('SearchValue');
        SEARCH.value = savedSearch;
      }

      /**
       * Runs when the page is loaded and everytime the user presses a key in the search field.
       *
       * Populates the local storage with the value in the search field.
       *
       * Converts any alpha character to upper case. If filter is set to favorite channels,
       * collect all of the favorited table rows and hid the empty query paragraph.
       * Otherwise get all of the table rows. Set a counter for hidden rows
       * and loop through all of the table rows.
       *
       * If the value in the search field matches any of the part of the displayed channels,
       * show those channels to the user and hide the empty query paragraph.
       *
       * Otherwise, hide the table row and add one to the hidden row counter.
       * If the hidden row counter equals the total number of rows than hide the whole table
       * and show the empty query paragraph.
       */
      function search() {
        populateSearchStorage();
        var channelLink, cName, emptyQuery, hiddenRowCount, searchValue, tr;
        searchValue = SEARCH.value.toUpperCase();
        emptyQuery = document.getElementById('empty-query');
        if (filters[1].checked === true) {
          tr = document.getElementsByClassName('favorites');
          emptyQuery.classList.add('hide');
        }
        else {
          tr = document.getElementsByTagName('tr');
        }
        hiddenRowCount = 0;
        for (h = 0; h < tr.length; h++) {
          channelLink = CHANNELNAMES[h].getElementsByTagName('a')[0];
          cName = channelLink.innerText;
          if (cName.toUpperCase().indexOf(searchValue) > -1) {
            TABLE.classList.remove('hide');
            tr[h].classList.remove('hide');
            emptyQuery.classList.add('hide');
          }
          else {
            tr[h].classList.add('hide');
            hiddenRowCount++;
            if (hiddenRowCount === tr.length) {
              TABLE.classList.add('hide');
              emptyQuery.removeAttribute('class');
            }
          }
        }
      }

      /**
       * Allows whole table cell to be clicked or touched and goes to the link in the
       * anchor tag.
       */
      function tdClick() {
        location.href = this.querySelector('a').href;
      }

      /**
       * If the event target has a button role, toggle it's state.
       *
       * @param {MouseEvent} event
       */
      function toggleButtonClickHandler (event) {
        if (event.currentTarget.getAttribute('role') === 'button') {
          toggleButtonState(event.currentTarget);
        }
      }

      /**
       * Toggles the toggle button's state on key down. Prevents default actions of
       * space and enter keys.
       *
       * If keydown is space, prevent default and ignore it. If keydown is enter,
       * toggle the favorite icon.
       *
       * @param {KeyboardEvent} event
       */
      function toggleButtonKeydownHandler (event) {
        if (event.keyCode === 32) {
          event.preventDefault();
        }
        else if (event.keyCode === 13) {
          event.preventDefault();
          toggleButtonState(event.currentTarget);
        }
      }

      /**
       * Toggles the channel filter based on the keydown event fired.
       *
       * If keydown is space, prevent the default action and ignore it.
       *
       * If the keydown event is the enter key, filter the channel list based on that event.
       *
       * If key down is any of the four arrow keys, reverse the label and filter the
       * channel list based on that reversed label.
       *
       * @param {KeyboardEvent} event
       */
       function toggleFilterKeydownHandler (event) {
         if (event.keyCode === 32) {
           event.preventDefault();
         }
         else if (event.keyCode === 13) {
           event.preventDefault();
           filterClick(event.currentTarget);
         }
         else if (event.keyCode > 36 && event.keyCode < 41) {
           var reverseLabel = (event.currentTarget.htmlFor === 'all') ? FAVORITELABEL : ALLLABEL;
           filterClick(reverseLabel);
         }
       }

      /**
       * If the space bar is pressed, prevent the default action and check what event
       * was fired. If the user pressed it on the channel filter, filter the channels.
       *
       * Otherwise it was pressed on the favorite toggle so it can be toggled.
       *
       * @param {KeyboardEvent} event
       */
      function toggleButtonKeyupHandler (event) {
        if (event.keyCode === 32) {
          event.preventDefault();
          if (event.currentTarget === ALLLABEL || event.currentTarget === FAVORITELABEL) {
            filterClick(event.currentTarget);
          }
          else toggleButtonState(event.currentTarget);
        }
      }

      /**
       * Toggles the toggle button's state between *pressed* and *not pressed*.
       *
       * @param {HTMLElement} button
       */
      function toggleButtonState (button) {
        var isAriaPressed = button.getAttribute('aria-pressed') === 'true';
        button.setAttribute('aria-pressed', isAriaPressed ? 'false' : 'true');
        button.innerText = (isAriaPressed === true) ? '♡' : '❤️';
        button.parentElement.classList = (isAriaPressed === true) ? 'all' : 'favorites';
        populateChannelStorage();
      }

      window.onload = init();


      //TODO need to finish this to only show in a laptop browser when a video is still playing and user tries to close window
      // Pause video before the user leaves, to handle when the user closes the browser
      window.addEventListener('beforeunload', function (e) {
        delete e['returnValue'];
        player1.pauseVideo();
      });


    </script>

    <!-- For users who have javascript turned off -->
    <noscript>
      <style>
        body {
          margin: 10px;
        }
        main, nav {
          display: none;
        }
        div {
          border: 1px solid black;
          margin: 0 auto;
          max-width: 450px;
          padding: 10px
        }
      </style>
      <div>
        <p>Hey, it looks like you have JavaScript turned off.</p>
        <p>Here's how to <a href="https://www.google.com/search?q=turn+on+javascript">turn on JavaScript</a>.</p>
        <p>If you purposely want it off, this app is very dependent on YouTube which needs JavaScript to run.</p>
        <p>You can just <a href="https://www.youtube.com/channel/UCd1sfSmij8b-w7wP_7IPvSA/playlists?feature=guide&view=1">go to YouTube</a> and check out all our playlists there. Enjoy!<p>
      </div>
    </noscript>

  </body>
</html>
