<!doctype html>
<!-- TODO When you add script to app, change **** line down below -->
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
    <title>Channels</title>
    <style>
      body {
        font-size: 20px;
        margin: 0
      }
      .dark {
       background-color: black 
      }
      main {
        margin: 0 auto;
        max-width: 700px;
        padding: 0 10px 70px;
        position: relative;
        z-index: 1
      }
      h1, p {
        text-align: center
      }
      #search {
        -webkit-appearance: none;
        -webkit-border-radius:0;
        border: solid #000 1px;
        border-radius:0;
        font-family: serif;
        font-size: 20px;
        padding: 6px;
        width: 175px
      }
      #search::placeholder {
        font-family: serif;
        font-size: 20px
      }
      input[type="search"]::-webkit-search-cancel-button {
        -webkit-appearance: none;
        background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAn0lEQVR42u3UMQrDMBBEUZ9WfQqDmm22EaTyjRMHAlM5K+Y7lb0wnUZPIKHlnutOa+25Z4D++MRBX98MD1V/trSppLKHqj9TTBWKcoUqffbUcbBBEhTjBOV4ja4l4OIAZThEOV6jHO8ARXD+gPPvKMABinGOrnu6gTNUawrcQKNCAQ7QeTxORzle3+sDfjJpPCqhJh7GixZq4rHcc9l5A9qZ+WeBhgEuAAAAAElFTkSuQmCC);
        background-repeat: no-repeat;
        background-size: 20px;
        cursor: pointer;
        display: block;
        height: 20px;
        width: 20px
      }
      fieldset {
        border: 0;
        margin: 1em 0;
        padding: 0;
        text-align: center
      }
      legend, input[type="radio"] {
        border: 0;
        clip: rect(1px, 1px, 1px, 1px);
        height: 1px;
        margin: -1px;
        overflow: hidden;
        padding: 0;
        position: absolute;
        width: 1px;
      }
      input[type="radio"]:checked + label {
        text-decoration: underline
      }
      #filter label {
        cursor: pointer
      }
      #filter label:last-child {
        margin-left: 20px
      }
      table {
        border-collapse: collapse;
        border-spacing: 0px;
        margin: 0 auto
      }
      td {
        border: 1px solid black;
        height: 36px;
        padding: 5px 12px
      }
      td {
        cursor: pointer
      }
      td a {
        text-decoration: none
      }
      .favorite, .channel {
        text-align: center;
        width: 30px
      }
      .search-item {
        padding: 5px 20px
      }
      nav {
        background-color: #000;
        bottom: 0;
        color: white;
        position: fixed;
        text-align: center;
        width: 100%;
        z-index: 1
      }
      nav ul {
        font-size: 0; /* no space between nav items */
        margin: 0 auto;
        max-width: 700px;
        padding: 0
      }
      nav li {
        border-right: 1px solid #fff;
        display: inline-block;
        font-size: 20px;
        list-style-type: none;
        margin: 0;
        padding: 10px 0;
        width: 45%
      }
      nav li:last-child {
        border: 0
      }
      nav a {
        color: #fff;
        display: inline-block;
        width: 100%
      }
      nav a:hover {
        color: red
      }
      .embed-container {
        height: 0;
        padding-bottom: 56.25%;
        position: relative
      }
      .embed-container iframe {
        height: 100%;
        left: 0;
        position: absolute;
        top: 0;
        width: 100%
      }
      #overlay {
        background-color: black;
        padding-bottom: 0
      }
      #overlay-title {
        color: white;
        font-size: 1.5em;
        margin: .83em 0
      }
      #close {
        background-color: black;
        border: 2px solid white;
        color: #fff;
        font: 20px serif;
        line-height: 2.5;
        margin-top: 30px;
        padding: 0 20px
      }
    </style>
  </head>
  <body>
    <main>
      <h1>Channels</h1>
      <p>
        <label for="search">Search:</label>
        <input aria-label="Search channels" id="search" name="search" placeholder="Dane, Kelly, etc." type="search">
      </p>
      <fieldset id="filter">
        <legend>Filter</legend>
        <input id="all" name="filter" tabindex="-1" type="radio" value="all">
        <label for="all" tabindex="0">All Channels</label>
        <input id="favorites" name="filter" tabindex="-1" type="radio" value="favorites">
        <label for="favorites" tabindex="0">Favorite Channels</label>
      </fieldset>
      <table>
        <tbody>
          <tr class="all">
            <td aria-label="Favorite channel" aria-pressed="false" class="favorite" id="Channel1" role="button" tabindex="0">♡</td>
            <td class="channel">
              <a href="dane-reynolds">1</a>
            </td>
            <td class="search-item">
              <a href="dane-reynolds">Dane Reynolds</a>
            </td>
          </tr>
          <tr class="all">
            <td aria-label="Favorite channel" aria-pressed="false" class="favorite" id="Channel2" role="button" tabindex="0">♡</td>
            <td class="channel">
              <a href="kelly-slater">2</a>
            </td>
            <td class="search-item">
              <a href="kelly-slater">Kelly Slater</a>
            </td>
          </tr>
          <tr class="all">
            <td aria-label="Favorite channel" aria-pressed="false" class="favorite" id="Channel3" role="button" tabindex="0">♡</td>
            <td class="channel">
              <a href="craig-anderson">3</a>
            </td>
            <td class="search-item">
              <a href="craig-anderson">Craig Anderson</a>
            </td>
          </tr>
        </tbody>
      </table>
      <p id="empty-query" hidden>No channels exist that match your query.</p>
      <p id="empty-filter" hidden>No favorite channels have been selected.</p>
    </main>
    <main id="overlay" hidden>
      <h1 id="overlay-title"></h1>
      <div class="embed-container">
        <div id="player1"></div>
        <div id="player2"></div>
        <div id="player3"></div>
      </div>
      <p>
        <button id="close">Close Channel</button>
      </p>
    </main>
    <nav>
      <ul>
        <li>Channels</li>
        <li>
          <a href="../movies/">Movies</a>
        </li>
      </ul>
    </nav>

    <script>

      
      // Load YouTube's iframe player API code asynchronously
      var tag = document.createElement('script');
      tag.src = "https://www.youtube.com/iframe_api";
      var firstScriptTag = document.getElementsByTagName('script')[0];
      firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);

      // Object containing info for all of the players
      var playerInfoList = [{
        id: 'player1',
        list: 'PLMxOsrgGH8n5HGL-UjsVoRQnemeWRcwkx',
        length: 60
      }, {
        id: 'player2',
        list: 'PLMxOsrgGH8n49WElPVU1isa7ifuUkZFMf',
        length: 6
      }, {
        id: 'player3',
        list: 'PLMxOsrgGH8n622jc8CpXksExjvI0z6Cxy',
        length: 4
      }];
      // Array of created players
      var players = new Array();
      // YouTube iframe API ready function
      function onYouTubeIframeAPIReady() {
        if (typeof playerInfoList === 'undefined') return;
        for (var y = 0; y < playerInfoList.length; y++) {
          var currentPlayer = createPlayer(playerInfoList[y]);
          players[y] = currentPlayer;
          document.getElementById(playerInfoList[y].id).setAttribute('hidden', '');
        }
      }
      // createPlayer function
      function createPlayer(playerInfo) {
        var playerPlaylist = playerInfo.id.charAt(0).toUpperCase() + playerInfo.id.slice(1) + 'Playlist';
        var playerPlaylistIndex = playerInfo.id.charAt(0).toUpperCase() + playerInfo.id.slice(1) + 'PlaylistIndex';
        var playerTime = playerInfo.id.charAt(0).toUpperCase() + playerInfo.id.slice(1) + 'Time';
        return new YT.Player(playerInfo.id, {
          height: '100%',
          width: '100%',
          events: {
            'onReady': function(event) {
              // Check if there is a playlist for this player in local storage
              if (localStorage.getItem(playerPlaylist) != null) {
                event.target.cuePlaylist(
                  localStorage.getItem(playerPlaylist),
                  localStorage.getItem(playerPlaylistIndex),
                  localStorage.getItem(playerTime)
                );
                event.target.setLoop(true);
              }
              else {
                // Random number decides which video will play first in the playlist
                var vid = Math.floor((Math.random() * playerInfo.length) + 1);
                event.target.cuePlaylist({
                  listType:'playlist',
                  list:playerInfo.list,
                  index:vid
                });
                //A second after the player is ready, it is set to shuffle all of the videos in the playlist. It is also set to loop the playlist.
                setTimeout(function() {
                  event.target.setShuffle({'shufflePlaylist' : true});
                }, 1000);
                event.target.setLoop(true); 
              }
            },
            'onStateChange': function(event) {
              if (event.data === 2) {
                localStorage.setItem(playerPlaylist, event.target.getPlaylist());
                localStorage.setItem(playerPlaylistIndex, event.target.getPlaylistIndex());
                localStorage.setItem(playerTime, event.target.getCurrentTime());
              }
            }
          }
        });
      }
      
      
      // Variables for counters and determining empty fields
      var a, b, c, d, e, f, g, h, i, j;
      const EMPTY = '';

      // Variables for all of the components
      const ALLLABEL = document.querySelector('label[for=all]');
      const CHANNELNAMES = document.querySelectorAll('.search-item');
      const CHANNELNUMBERS = document.querySelectorAll('.channel');
      const EMPTYFILTER = document.getElementById('empty-filter');
      const EMPTYQUERY = document.getElementById('empty-query');
      const FAVORITELABEL = document.querySelector('label[for=favorites]');
      const FAVORITES = document.querySelectorAll('.favorite');
      const MAIN = document.querySelector('main');
      const SEARCH = document.querySelector('#search');
      const TABLE = document.querySelector('table');
      var filters = document.querySelectorAll('input[name=filter]');


      const BODY = document.querySelector('body');
      const NAV = document.querySelector('nav');
      const OVERLAY = document.getElementById('overlay');
      const OVERLAYTITLE = document.getElementById('overlay-title');
      const CLOSE = document.getElementById('close');
      const LINK = document.querySelectorAll('a');
      CLOSE.addEventListener('click', close);
      const PAGETITLE = 'Channels';


      function init() {

        // Initiate and populate local storage if there isn't any
        // Otherwise set up page with saved components
        if (localStorage.length === 0) {
          populateChannelStorage();
          populateFilterStorage();
          populateSearchStorage();
        } else {
          setChannelStyles();
          setFilterStyles();
          setSearchValue();
        }

        // If user left anything in the search field, run the search function
        if (SEARCH.value !== EMPTY) {
          search();
        }

        // Add event listeners - search, table cell, filter, and label interactions
        SEARCH.addEventListener('keyup', search);
        SEARCH.addEventListener('search', search);
        for (a = 0; a < CHANNELNAMES.length; a++) {
          FAVORITES[a].addEventListener('click', toggleButtonClickHandler);
          FAVORITES[a].addEventListener('keydown', toggleButtonKeydownHandler);
          FAVORITES[a].addEventListener('keyup', toggleButtonKeyupHandler);
          CHANNELNUMBERS[a].addEventListener('click', tdClick);
          CHANNELNAMES[a].addEventListener('click', tdClick);
        }
        for (b = 0; b < filters.length; b++){
          filters[b].addEventListener('click', filterClick);
        }
        ALLLABEL.addEventListener('keydown', toggleFilterKeydownHandler);
        ALLLABEL.addEventListener('keyup', toggleButtonKeyupHandler);
        FAVORITELABEL.addEventListener('keydown', toggleFilterKeydownHandler);
        FAVORITELABEL.addEventListener('keyup', toggleButtonKeyupHandler);
        for (i = 0; i < LINK.length; i++) {
          LINK[i].addEventListener('click', linkClick, false);
        }
        
      } // end init


      /**
       * Runs when user presses close channel button
       */
      function close() {
        pausePlayers();
        hideOverlay();
        var pathArray = window.location.pathname.split('/');
        var fullURL = window.location.protocol + "//" + window.location.host;
        for (i = 0; i < 3; i++) {
          fullURL += pathArray[i];
          fullURL += "/";
        }
        history.pushState(null, null, fullURL);
      }
      function linkClick(e) {
        if (e.target.innerHTML == 'Movies') {
          return true;
        }
        else {
          e.preventDefault();
          var data = e.target.getAttribute('href'),
              url = data + '/';
          history.pushState(data, null, url);
          switch (e.target.innerHTML) {
            case '1':
            case 'Dane Reynolds':
              showOverlay(0, 'Dane Reynolds Channel');
              break;
            case '2':
            case 'Kelly Slater':
              showOverlay(1, 'Kelly Slater Channel');
              break;
            case '3':
            case 'Craig Anderson':
              showOverlay(2, 'Craig Anderson Channel');
          }
          e.stopPropagation();
        }
      }
      function showOverlay(playerIndex, channelTitle) {
        MAIN.setAttribute('hidden', '');
        BODY.setAttribute('class', 'dark');
        OVERLAY.removeAttribute('hidden');
        OVERLAYTITLE.innerText = channelTitle;
        players[playerIndex].f.removeAttribute('hidden');
        players[playerIndex].playVideo();
        document.title = channelTitle;
        NAV.setAttribute('hidden', '');
      }
      function hideOverlay() {
        MAIN.removeAttribute('hidden');
        BODY.removeAttribute('class');
        NAV.removeAttribute('hidden');
        OVERLAY.setAttribute('hidden', '');
        OVERLAYTITLE.innerText = '';
        document.title = PAGETITLE;
      }
      function pausePlayers() {
        players.forEach(function (el) {
          el.pauseVideo();
          el.f.setAttribute('hidden', '');
        });
      }
      window.addEventListener('popstate', function(e){
        var recentChannel = e.state;
        if (recentChannel === null){
          pausePlayers();
          hideOverlay();
        }
        else {
          switch (recentChannel) {
            case 'dane-reynolds':
              showOverlay(0, 'Dane Reynolds Channel');
              break;
            case 'kelly-slater':
              showOverlay(1, 'Kelly Slater Channel');
              break;
            case 'craig-anderson':
              showOverlay(2, 'Craig Anderson Channel');
          }
        }
      });


      /**
       * Runs when user interacts with the channel filter (by click or keyboard).
       * Filter the page contents according to the incoming channel filter.
       * Populate filter in local storage.
       *
       * @param {KeyboardEvent} event
       */
      function filterClick(event) {
        if (this.value === 'favorites' || event.htmlFor === 'favorites') {
          filters[0].removeAttribute('checked');
          filters[1].setAttribute('checked', '');
          filters[1].checked = true;
          populateFilterStorage();
          filterFavorites();
        }
        else {
          filters[0].setAttribute('checked', '');
          filters[0].checked = true;
          ALLLABEL.focus();
          filters[1].removeAttribute('checked');
          EMPTYFILTER.setAttribute('hidden', '');
          populateFilterStorage();
          // If user left anything in the search field
          var searchValue = SEARCH.value.toUpperCase();
          if (searchValue !== EMPTY) {
            var tr = document.getElementsByTagName('tr');
            var hiddenRowCount = 0;
            for (j = 0; j < tr.length; j++) {
              var channelLink = CHANNELNAMES[j].getElementsByTagName('a');
              var cName = channelLink[0].innerText;
              if (cName.toUpperCase().indexOf(searchValue) > -1) {
                TABLE.removeAttribue('hidden');
                tr[j].removeAttribute('hidden');
                EMPTYQUERY.setAttribute('hidden', '');
              }
              else {
                tr[j].setAttribute('hidden', '');
                hiddenRowCount++;
                if (hiddenRowCount === tr.length) {
                  TABLE.setAttribute('hidden', '');
                  EMPTYQUERY.removeAttribute('hidden');
                }
              }
            }
          }
          else {
            EMPTYFILTER.setAttribute('hidden', '');
            TABLE.removeAttribute('hidden');
            var tr = document.getElementsByTagName('tr');
            for (c = 0; c < tr.length; c++) {
              tr[c].removeAttribute('hidden');
            }
          }
        }
      }

      /**
       * When filter is set to favorite channels, focus on the filter, hide rows
       * with the all channels filter.
       *
       * If no favorites are selected, hide the whole table and show the empty
       * filter paragraph.
       */
      function filterFavorites() {
        FAVORITELABEL.focus();
        var allOnlyRows = document.querySelectorAll('.all');
        for (d = 0; d < allOnlyRows.length; d++) {
          allOnlyRows[d].setAttribute('hidden', '');
        }
        if (allOnlyRows.length === 3) { // **** change this number to the number of channels
          TABLE.setAttribute('hidden', '');
          EMPTYFILTER.removeAttribute('hidden');
        }
      }

      /**
       * Populate local storage with the id of the channel when the favorite
       * icon is pressed. Also save whether the icon is pressed and the channel filter.
       * Set the channel styles on their respective componets.
       */
      function populateChannelStorage() {
        for (e = 0; e < FAVORITES.length; e++) {
          localStorage.setItem(FAVORITES[e].id, FAVORITES[e].innerText);
          localStorage.setItem(FAVORITES[e].id+'Pressed', FAVORITES[e].getAttribute('aria-pressed'));
          localStorage.setItem(FAVORITES[e].id+'Filter', FAVORITES[e].parentElement.classList[0]);
        }
        setChannelStyles();
      }

      /**
       * If no filter is checked (likely on user's first visit), set the filter to all channels.
       * Populate local storage with the channel filter that is selected.
       */
      function populateFilterStorage() {
        if (filters[0].checked === false && filters[1].checked === false){
          filters[0].setAttribute('checked', '');
        }
        for (f = 0; f < filters.length; f++){
          if (filters[f].checked) {
            localStorage.setItem('FilterSelected', filters[f].value);
          }
        }
        setFilterStyles();
      }

      /**
       * Populate local storage with the value that is in the search field.
       * Sets the search field value to the value that is saved in the local storage.
       */
      function populateSearchStorage() {
        localStorage.setItem('SearchValue', SEARCH.value);
        setSearchValue();
      }

      /**
       * Runs when the page is loaded and everytime the user presses a key in the search field.
       *
       * Populates the local storage with the value in the search field.
       *
       * Converts any alpha character to upper case. If filter is set to favorite channels,
       * collect all of the favorited table rows and hid the empty query paragraph.
       * Otherwise get all of the table rows. Set a counter for hidden rows
       * and loop through all of the table rows.
       *
       * If the value in the search field matches any of the part of the displayed channels,
       * show those channels to the user and hide the empty query paragraph.
       *
       * Otherwise, hide the table row and add one to the hidden row counter.
       * If the hidden row counter equals the total number of rows than hide the whole table
       * and show the empty query paragraph.
       */
      function search() {
        populateSearchStorage();
        var channelLink, cName, hiddenRowCount, searchValue, tr;
        searchValue = SEARCH.value.toUpperCase();
        if (filters[1].checked === true) {
          tr = document.getElementsByClassName('favorites');
          EMPTYQUERY.setAttribute('hidden', '');
        }
        else {
          tr = document.getElementsByTagName('tr');
        }
        hiddenRowCount = 0;
        for (h = 0; h < tr.length; h++) {
          channelLink = CHANNELNAMES[h].getElementsByTagName('a');
          cName = channelLink[0].innerText;
          if (cName.toUpperCase().indexOf(searchValue) > -1) {
            TABLE.removeAttribute('hidden');
            tr[h].removeAttribute('hidden');
            EMPTYQUERY.setAttribute('hidden', '');
          }
          else {
            tr[h].setAttribute('hidden', '');
            hiddenRowCount++;
            if (hiddenRowCount === tr.length) {
              TABLE.setAttribute('hidden', '');
              EMPTYQUERY.removeAttribute('hidden');
            }
          }
        }
      }

      /**
       * Sets the styles of all the channels based on their values in local storage.
       */
      function setChannelStyles() {
        var channelIcons = [];
        var rowFilters = [];
        var arias = [];
        for (g = 0; g < FAVORITES.length; g++) {
          channelIcons[g] = localStorage.getItem(FAVORITES[g].id);
          rowFilters[g] = localStorage.getItem(FAVORITES[g].id+'Filter');
          arias[g] = localStorage.getItem(FAVORITES[g].id+'Pressed');
          FAVORITES[g].innerText = channelIcons[g];
          FAVORITES[g].parentElement.classList = rowFilters[g];
          FAVORITES[g].setAttribute('aria-pressed', arias[g]);
        }
      }

      /**
       * Sets the style of the filter based on the values saved in local storage.
       * If the filter is set to favorite channels, displays the favorite channels.
       */
      function setFilterStyles() {
        var filterChecked;
        filterChecked = localStorage.getItem('FilterSelected');
        if (filterChecked === 'all') {
          filters[0].checked = true;
          filters[0].setAttribute('checked', '');
        }
        else {
          filters[1].checked = true;
          filters[1].setAttribute('checked', '');
          filterFavorites();
        }
      }

      /**
       * Sets the search field value to the value that is saved in the local storage.
       */
      function setSearchValue() {
        var savedSearch = localStorage.getItem('SearchValue');
        SEARCH.value = savedSearch;
      }

      /**
       * Allows whole table cell to be clicked or touched and goes to the link in the
       * anchor tag.
       */
      function tdClick(e) {
        location.href = this.querySelector('a').href;
      }

      /**
       * If the event target has a button role, toggle it's state.
       *
       * @param {MouseEvent} event
       */
      function toggleButtonClickHandler (event) {
        if (event.currentTarget.getAttribute('role') === 'button') {
          toggleButtonState(event.currentTarget);
        }
      }

      /**
       * Toggles the toggle button's state on key down. Prevents default actions of
       * space and enter keys.
       *
       * If keydown is space, prevent default and ignore it. If keydown is enter,
       * toggle the favorite icon.
       *
       * @param {KeyboardEvent} event
       */
      function toggleButtonKeydownHandler (event) {
        if (event.keyCode === 32) {
          event.preventDefault();
        }
        else if (event.keyCode === 13) {
          event.preventDefault();
          toggleButtonState(event.currentTarget);
        }
      }

      /**
       * Toggles the channel filter based on the keydown event fired.
       *
       * If keydown is space, prevent the default action and ignore it.
       *
       * If the keydown event is the enter key, filter the channel list based on that event.
       *
       * If key down is any of the four arrow keys, reverse the label and filter the
       * channel list based on that reversed label.
       *
       * @param {KeyboardEvent} event
       */
       function toggleFilterKeydownHandler (event) {
         if (event.keyCode === 32) {
           event.preventDefault();
         }
         else if (event.keyCode === 13) {
           event.preventDefault();
           filterClick(event.currentTarget);
         }
         else if (event.keyCode > 36 && event.keyCode < 41) {
           var reverseLabel = (event.currentTarget.htmlFor === 'all') ? FAVORITELABEL : ALLLABEL;
           filterClick(reverseLabel);
         }
       }

      /**
       * If the space bar is pressed, prevent the default action and check what event
       * was fired. If the user pressed it on the channel filter, filter the channels.
       *
       * Otherwise it was pressed on the favorite toggle so it can be toggled.
       *
       * @param {KeyboardEvent} event
       */
      function toggleButtonKeyupHandler (event) {
        if (event.keyCode === 32) {
          event.preventDefault();
          if (event.currentTarget === ALLLABEL || event.currentTarget === FAVORITELABEL) {
            filterClick(event.currentTarget);
          }
          else toggleButtonState(event.currentTarget);
        }
      }

      /**
       * Toggles the toggle button's state between *pressed* and *not pressed*.
       *
       * @param {HTMLElement} button
       */
      function toggleButtonState (button) {
        var filterSelected = localStorage.getItem('FilterSelected');
        var isAriaPressed = button.getAttribute('aria-pressed') === 'true';
        button.setAttribute('aria-pressed', isAriaPressed ? 'false' : 'true');
        button.innerText = (isAriaPressed === true) ? '♡' : '❤️';
        button.parentElement.classList = (isAriaPressed === true) ? 'all' : 'favorites';
        if (filterSelected === 'favorites' && button.innerText === '♡') {
          filterFavorites();
        }
        populateChannelStorage();
      }

      window.onload = init();


      //TODO need to finish this to only show in a laptop browser when a video is still playing and user tries to close window
      // Pause video before the user leaves, to handle when the user closes the browser
      window.addEventListener('beforeunload', function (e) {
        delete e['returnValue'];
        pausePlayers();
      });


    </script>

    <!-- For users who have javascript turned off -->
    <noscript>
      <style>
        body {
          margin: 10px;
        }
        main, nav {
          display: none;
        }
        div {
          border: 1px solid black;
          margin: 0 auto;
          max-width: 450px;
          padding: 10px
        }
      </style>
      <div>
        <p>Hey, it looks like you have JavaScript turned off.</p>
        <p>Here's how to <a href="https://www.google.com/search?q=turn+on+javascript">turn on JavaScript</a>.</p>
        <p>If you purposely want it off, this app is very dependent on YouTube which needs JavaScript to run.</p>
        <p>You can just <a href="https://www.youtube.com/channel/UCd1sfSmij8b-w7wP_7IPvSA/playlists?feature=guide&view=1">go to YouTube</a> and check out all our playlists there. Enjoy!<p>
      </div>
    </noscript>

  </body>
</html>
