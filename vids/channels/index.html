<!doctype html> 
<!-- TODO When you add script to app, don't forget playerInfoList variable on this line **** -->
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0" name="viewport">
    <title>Channels</title>
    <style>
      body {
        background-color: #000;
        color: #fff;
        font-size: 20px;
        margin: 0
      }
      main {
        margin: 0 auto;
        max-width: 700px;
        padding: 0 10px 70px;
        position: relative;
        text-align: center;
        z-index: 1
      }
      a, a:visited {
        color: #fff
      }
      #search {
        -webkit-appearance: none;
        -webkit-border-radius:0;
        background-color: #000;
        border: solid #fff 1px;
        border-radius:0;
        color: #fff;
        font-family: serif;
        font-size: 20px;
        padding: 6px;
        width: 175px
      }
      #search::placeholder {
        font-family: serif;
        font-size: 20px
      }
      input[type="search"]::-webkit-search-cancel-button {
        -webkit-appearance: none;
        background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAn0lEQVR42u3UMQrDMBBEUZ9WfQqDmm22EaTyjRMHAlM5K+Y7lb0wnUZPIKHlnutOa+25Z4D++MRBX98MD1V/trSppLKHqj9TTBWKcoUqffbUcbBBEhTjBOV4ja4l4OIAZThEOV6jHO8ARXD+gPPvKMABinGOrnu6gTNUawrcQKNCAQ7QeTxORzle3+sDfjJpPCqhJh7GixZq4rHcc9l5A9qZ+WeBhgEuAAAAAElFTkSuQmCC);
        background-repeat: no-repeat;
        background-size: 20px;
        cursor: pointer;
        display: block;
        height: 20px;
        width: 20px
      }
      fieldset {
        border: 0;
        margin: 1em 0;
        padding: 0;
        text-align: center
      }
      legend, input[type="radio"] {
        border: 0;
        clip: rect(1px, 1px, 1px, 1px);
        height: 1px;
        margin: -1px;
        overflow: hidden;
        padding: 0;
        position: absolute;
        width: 1px;
      }
      input[type="radio"]:checked + label {
        text-decoration: underline
      }
      fieldset label {
        cursor: pointer
      }
      fieldset label:last-child {
        margin-left: 20px
      }
      table {
        border-collapse: collapse;
        border-spacing: 0px;
        margin: 0 auto
      }
      td {
        border-bottom: 1px solid #303030;
        border-right: 0;
        cursor: pointer;
        height: 36px;
        padding: 5px 12px
      }
      td a {
        text-decoration: none
      }
      .favorite, .channel-number {
        width: 30px
      }
      .channel-name {
        padding: 5px 20px;
        text-align: left
      }
      nav {
        background-color: #303030;
        bottom: 0;
        margin: 0 auto;
        padding: 10px 0;
        position: fixed;
        text-align: center;
        width: 100%;
        z-index: 1
      }
      nav a:hover {
        color: red
      }
      .embed-container {
        height: 0;
        padding-bottom: 56.25%;
        position: relative
      }
      .embed-container iframe {
        height: 100%;
        left: 0;
        position: absolute;
        top: 0;
        width: 100%
      }
      #overlay {
        padding-bottom: 0
      }
      #overlay-title {
        font-size: 1.5em;
        margin: .83em 0
      }
      #close {
        background-color: #000;
        border: 2px solid #fff;
        color: #fff;
        font: 20px serif;
        line-height: 2.5;
        margin: 50px 0 20px;
        padding: 0 20px
      }
    </style>
  </head>
  <body>
    <main>
      <h1>Channels</h1>
      <label for="search">Search:</label>
      <input aria-label="Search channels" id="search" name="search" placeholder="Dane, Kelly, etc." type="search">
      <fieldset>
        <legend>Filter</legend>
        <input id="all" name="filter" tabindex="-1" type="radio" value="all">
        <label for="all" tabindex="0">All Channels</label>
        <input id="favorites" name="filter" tabindex="-1" type="radio" value="favorites">
        <label for="favorites" tabindex="0">Favorite Channels</label>
      </fieldset>
      <table>
        <tbody>
          <tr class="all">
            <td aria-label="Favorite channel" aria-pressed="false" class="favorite" role="button" tabindex="0">♡</td>
            <td class="channel-number">
              <a href="dane-reynolds">1</a>
            </td>
            <td class="channel-name">
              <a href="dane-reynolds">Dane Reynolds</a>
            </td>
          </tr>
          <tr class="all">
            <td aria-label="Favorite channel" aria-pressed="false" class="favorite" role="button" tabindex="0">♡</td>
            <td class="channel-number">
              <a href="kelly-slater">2</a>
            </td>
            <td class="channel-name">
              <a href="kelly-slater">Kelly Slater</a>
            </td>
          </tr>
          <tr class="all">
            <td aria-label="Favorite channel" aria-pressed="false" class="favorite" role="button" tabindex="0">♡</td>
            <td class="channel-number">
              <a href="craig-anderson">3</a>
            </td>
            <td class="channel-name">
              <a href="craig-anderson">Craig Anderson</a>
            </td>
          </tr>
        </tbody>
      </table>
      <p id="empty-query" hidden>No channels exist that match your query.</p>
      <p id="empty-filter" hidden>No favorite channels have been selected.</p>
    </main>
    <main id="overlay" hidden>
      <h1 id="overlay-title"></h1>
      <div class="embed-container">
        <div id="DaneReynoldsPlayer"></div>
        <div id="KellySlaterPlayer"></div>
        <div id="CraigAndersonPlayer"></div>
      </div>
      <button id="close">Close Channel</button>
    </main>
    <nav>
      <a href="..">Home</a> &nbsp;|&nbsp;
      Channels &nbsp;|&nbsp;
      <a href="../shows/">Shows</a> &nbsp;|&nbsp;
      <a href="../movies/">Movies</a>
    </nav>

    <script src="https://www.youtube.com/iframe_api"></script>
    <script>
    (function(){

      /**
       * The playerInfoList object containing info for all of the players
       * (this probably can be pulled dynamically from the data file in the app so probably won't be needed)
       */
      const playerInfoList = [{
        length: 60,
        playlist: 'PLMxOsrgGH8n5HGL-UjsVoRQnemeWRcwkx',
        playlistName: 'DaneReynolds'
      }, {
        length: 6,
        playlist: 'PLMxOsrgGH8n49WElPVU1isa7ifuUkZFMf',
        playlistName: 'KellySlater'
      }, {
        length: 4,
        playlist: 'PLMxOsrgGH8n622jc8CpXksExjvI0z6Cxy',
        playlistName: 'CraigAnderson'
      }];

      /**
       * Components and variables
       */
      const ALL_LABEL = document.querySelector('label[for=all]');
      const BODY = document.querySelector('body');
      const CHANNEL_NAMES = document.querySelectorAll('.channel-name');
      const CHANNEL_NUMBERS = document.querySelectorAll('.channel-number');
      const CLOSE = document.getElementById('close');
      const EMPTY = '';
      const EMPTY_FILTER = document.getElementById('empty-filter');
      const EMPTY_QUERY = document.getElementById('empty-query');
      const FAVORITE_LABEL = document.querySelector('label[for=favorites]');
      const FAVORITES = document.querySelectorAll('.favorite');
      const FILTERS = document.querySelectorAll('input[name=filter]');
      const LINKS = document.querySelectorAll('a');
      const MAIN = document.querySelector('main');
      const NAV = document.querySelector('nav');
      const OVERLAY = document.getElementById('overlay');
      const OVERLAY_TITLE = document.getElementById('overlay-title');
      const PAGE_TITLE = 'Channels';
      let players = new Array();
      const SEARCH = document.querySelector('#search');
      const TABLE = document.querySelector('table');
      const TABLE_ROWS = document.getElementsByTagName('tr');

      /**
       * Simple Event listeners
       */
      ALL_LABEL.addEventListener('keydown', toggleFilterKeydownHandler, false);
      ALL_LABEL.addEventListener('keyup', toggleButtonKeyupHandler, false);
      CLOSE.addEventListener('click', close, false);
      for (let i = 0, namesLength = CHANNEL_NAMES.length; i < namesLength; i++) {
        CHANNEL_NAMES[i].addEventListener('click', tdClick, false);
        CHANNEL_NUMBERS[i].addEventListener('click', tdClick, false);
        FAVORITES[i].addEventListener('click', toggleButtonClickHandler, false);
        FAVORITES[i].addEventListener('keydown', toggleButtonKeydownHandler, false);
        FAVORITES[i].addEventListener('keyup', toggleButtonKeyupHandler, false);
      }
      FAVORITE_LABEL.addEventListener('keydown', toggleFilterKeydownHandler, false);
      FAVORITE_LABEL.addEventListener('keyup', toggleButtonKeyupHandler, false);
      for (let j = 0, filtersLength = FILTERS.length; j < filtersLength; j++) {
        FILTERS[j].addEventListener('click', filterClick, false);
      }
      for (let k = 0, linksLength = LINKS.length; k < linksLength ; k++) {
        LINKS[k].addEventListener('click', linkClick, false);
      }
      SEARCH.addEventListener('keyup', search, false);
      SEARCH.addEventListener('search', search, false);

      /**
       * beforeunload event listener function
       *
       * When the user closes the browser window, delete the event returnValue so alert doesn't show and pause all
       * of the players by calling the pausePlayers function.
       */
      window.addEventListener('beforeunload', function(event) {
        delete event['returnValue'];
        pausePlayers();
      }, false);

      /**
       * DOMContentLoaded event listener
       *
       * Call the init function after the DOM content is loaded.
       */
      document.addEventListener('DOMContentLoaded',init, false);

      /**
       * popstate event listener function
       *
       * Called every time the overlay is displayed and the back button is pressed.
       *
       * If the event.state is null, pause the players, hide the overlay, set the current player index value in local
       * storage to none, and set the document title to 'Channels'.
       *
       * Otherwise, create a title variable by taking the event.state, replacing the dash with a space, capitalizing
       * the two words, and adding the word Channel to it. Choose which overlay to display and set the document
       * title to the title variable created.
       *
       * @param {popstate} event
       */
      window.addEventListener('popstate', function(event){
        if (event.state === null) {
          pausePlayers();
          hideOverlay();
          localStorage.setItem('CurrentPlayerIndex', 'none');
          document.title = PAGE_TITLE;
        }
        else {
          let path = event.state;
          let removeDash = path.replace(/-/g, ' ');
          let addCaps = removeDash.replace(/(^\w|\s\w)/g, m => m.toUpperCase());
          let title = addCaps + ' Channel';
          chooseOverlay(event);
          document.title = title;
        }
      }, false); // end popstate listener

      /**
       * chooseOverlay function
       *
       * Called by linkClick function and popstate event listener.
       *
       * If the event calling the function is popstate, set the trigger to event.state, otherwise set it to the last
       * path of the event.target.href.
       *
       * Show the corresponding overlay of the event trigger. Default to Dane Reynolds channel.
       *
       * @param {MouseEvent, PopStateEvent} event
       */
      function chooseOverlay(event) {
        let href = [];
        let trigger = '';
        if (event.type === 'popstate') {
          trigger = event.state;
        }
        else {
          href = event.target.href.split('/');
          trigger = href[href.length - 1];
        }
        switch (trigger) {
          //case '1':
          case 'dane-reynolds':
          //case 'Dane Reynolds':
            showOverlay(0, 'Dane Reynolds Channel');
            break;
          //case '2':
          case 'kelly-slater':
          //case 'Kelly Slater':
            showOverlay(1, 'Kelly Slater Channel');
            break;
          //case '3':
          case 'craig-anderson':
          //case 'Craig Anderson':
            showOverlay(2, 'Craig Anderson Channel');
            break;
          default:
            showOverlay(0, 'Dane Reynolds Channel');
        }
      } // end chooseOverlay function

      /**
       * close function
       *
       * Called by close button event listener.
       *
       * Builds url of channels page for history. Calls pausePlayers and hideOverlay functions to pause players and hide the 
       * overlay. Sets current player index local storage value to none. Pushes the url to history state and sets the
       * document title to Channels.
       */
      function close() {
        const pathArray = window.location.pathname.split('/');
        let fullURL = window.location.protocol + "//" + window.location.host;
        for (let i = 0; i < 3; i++) {
          fullURL += pathArray[i];
          fullURL += "/";
        }
        pausePlayers();
        hideOverlay();
        localStorage.setItem('CurrentPlayerIndex', 'none');
        history.pushState(null, null, fullURL);
        document.title = PAGE_TITLE;
      }

      /**
       * createPlayer function
       *
       * Called from onYouTubeIframeAPIReady function.
       *
       * Creates a YouTube player for each channnel.
       *
       * Create variables for player name and local storage (playlist, playlist index, and player index time).
       *
       * Create each player with the player name, height and width of player (100% for responsive), and events.
       * 
       * The onReady event fires when each player is ready. It first checks if there is a playlist for the player
       * in local storage. If there is, it retrieves the playlist, index, and time for that player and cues the playlist.
       * It also sets the playlist to loop. If the player isn't found in local storage, it creates a random number
       * based on the number of videos in the playlist to decide which video to play first and creates a new playlist.
       * A second after the playlist is created, it is set to shuffle all of the videos in the playlist. It is also set 
       * to loop the playlist.
       *
       * The onStateChange event updates all of the local storage items (playlist, index, and time) every three seconds
       * when the player is playing (event.data = 1) and everytime the player is paused (event.data = 2). The three
       * second timer is cleared on player pause.
       *
       * @param {Object} playerInfo
       */
      function createPlayer(playerInfo) {
        let intervalId;
        const playerName = playerInfo.playlistName + 'Player';
        const playerPlaylist = playerInfo.playlistName + 'Playlist';
        const playerPlaylistIndex = playerInfo.playlistName + 'PlaylistIndex';
        const playerTime = playerInfo.playlistName + 'IndexTime';
        return new YT.Player(playerName, {
          height: '100%',
          width: '100%',
          events: {
            'onReady': function(event) {
              if (localStorage.getItem(playerPlaylist) != null) {
                event.target.cuePlaylist(
                  localStorage.getItem(playerPlaylist),
                  localStorage.getItem(playerPlaylistIndex),
                  localStorage.getItem(playerTime)
                );
                event.target.setLoop(true);
              }
              else {
                let index = Math.floor((Math.random() * playerInfo.length) + 1);
                event.target.cuePlaylist({
                  listType:'playlist',
                  list:playerInfo.playlist,
                  index:index
                });
                setTimeout(function() {
                  event.target.setShuffle({'shufflePlaylist' : true});
                }, 1000);
                event.target.setLoop(true); 
              }
            }, // end onReady event
            'onStateChange': function(event) {
              if (event.data === 1) {
                intervalId = setInterval(function() {
                  localStorage.setItem(playerPlaylist, event.target.getPlaylist());
                  localStorage.setItem(playerPlaylistIndex, event.target.getPlaylistIndex());
                  localStorage.setItem(playerTime, event.target.getCurrentTime());
                }, 3000);
              }
              else if (event.data === 2) {
                clearInterval(intervalId);
                localStorage.setItem(playerPlaylist, event.target.getPlaylist());
                localStorage.setItem(playerPlaylistIndex, event.target.getPlaylistIndex());
                localStorage.setItem(playerTime, event.target.getCurrentTime());
              }
            } // end onStateChange event
          } // end events
        }); // end return
      } // end createPlayer function

      /**
       * filterAll function
       *
       * Called by filterClick function.
       *
       * If search field isn't empty, loop through all table rows. If the channel
       * name matches what's in the search field, remove the hidden attribute on the table and all of it's rows,
       * and hide the empty query element. Ottherwise, hide all of the table rows and increase the hidden row
       * counter. If the counter equals the total number of table rows, hide the table and show the empty query
       * element.
       *
       * If the search field is empty, hide the empty filter element, show the table and all of it's rows.
       */
      function filterAll() {
        const searchValue = SEARCH.value.toUpperCase();
        if (searchValue !== EMPTY) {
          let hiddenRowCount = 0;
          for (let i = 0, trLength = TABLE_ROWS.length; i < trLength; i++) {
            const channelLink = CHANNEL_NAMES[i].getElementsByTagName('a');
            const cName = channelLink[0].innerText;
            if (cName.toUpperCase().indexOf(searchValue) > -1) {
              TABLE.removeAttribue('hidden');
              TABLE_ROWS[i].removeAttribute('hidden');
              EMPTY_QUERY.setAttribute('hidden', '');
            }
            else {
              TABLE_ROWS[i].setAttribute('hidden', '');
              hiddenRowCount++;
              if (hiddenRowCount === TABLE_ROWS.length) {
                TABLE.setAttribute('hidden', '');
                EMPTY_QUERY.removeAttribute('hidden');
              }
            }
          } // end loop
        }
        else {
          EMPTY_FILTER.setAttribute('hidden', '');
          TABLE.removeAttribute('hidden');
          for (let j = 0, trLength = TABLE_ROWS.length; j < trLength; j++) {
            TABLE_ROWS[j].removeAttribute('hidden');
          }
        }
      } // end filterAll function

      /**
       * filterClick function
       *
       * Called by FILTERS event listener, the toggleFilterKeydownHandler function, and the toggleButtonKeyupHandler function.
       *
       * Runs when user interacts with the channel filter (by click or keyboard).
       *
       * Update document with selection made by user. If favorites filter or else all filter.
       *
       * Populate filter information in local storage.
       *
       * Filter the document content according to the incoming channel filter selected.
       *
       * @param {KeyboardEvent} event
       */
      function filterClick(event) {
        if (this.value === 'favorites' || event.htmlFor === 'favorites') {
          FILTERS[0].removeAttribute('checked');
          FILTERS[1].setAttribute('checked', '');
          FILTERS[1].checked = true;
          populateFilterStorage();
          filterFavorites();
        }
        else {
          FILTERS[0].setAttribute('checked', '');
          FILTERS[0].checked = true;
          ALL_LABEL.focus();
          FILTERS[1].removeAttribute('checked');
          EMPTY_FILTER.setAttribute('hidden', '');
          populateFilterStorage();
          filterAll();
        }
      } // end filterClick function

      /**
       * filterFavorites function
       *
       * Called by filterClick function, the setFilterStyles function, and the toggleButtonState function.
       *
       * When filter is set to favorite channels, focus on the filter and hide rows that
       * have the all channels filter on them.
       *
       * If no favorites are selected, hide the whole table and show the empty
       * filter paragraph.
       */
      function filterFavorites() {
        FAVORITE_LABEL.focus();
        let allOnlyRows = document.querySelectorAll('.all');
        for (let i = 0, allLength = allOnlyRows.length; i < allLength; i++) {
          allOnlyRows[i].setAttribute('hidden', '');
        }
        if (allOnlyRows.length === playerInfoList.length) { // **** make sure you change this variable for prod
          TABLE.setAttribute('hidden', '');
          EMPTY_FILTER.removeAttribute('hidden');
        }
      }

      /**
       * hideOverlay function
       *
       * Called by close function and popstate event listener.
       *
       * Unhides the main and nav elements. Hides the overlay element and removes the text for the overlay H1.
       */
      function hideOverlay() {
        MAIN.removeAttribute('hidden');
        NAV.removeAttribute('hidden');
        OVERLAY.setAttribute('hidden', '');
        OVERLAY_TITLE.innerText = '';
      }

      /**
       * init function
       *
       * Called by the DOMContentLoaded event listener.
       *
       * Checks to see if local storage exists for channel, filter, or search components. 
       * If that information isn't in local storage, it populates it with what is currently on the page. 
       * If local storage exists, it sets up the page with components from the information in local storage.
       *
       * If the user left anything in the search field, it runs the search function.
       */
      function init() {
        if (localStorage.length === 0) {
          populateChannelStorage();
          populateFilterStorage();
          populateSearchStorage();
        } else {
          setChannelStyles();
          setFilterStyles();
          setSearchValue();
        }
        if (SEARCH.value !== EMPTY) {
          search();
        }
      } // end init function

      /**
       * linkClick function
       *
       * Called by the LINKS event listener.
       *
       * Event handler action for all links in the document. If user clicks on any of the nav links, perform 
       * the default link action.
       *
       * Otherwise, prevent the default action of an href click. Choose which overlay to display by calling the
       * chooseOverlay function. Create data for the history pushState and push that information to history. Set
       * the document title to be the name of the channel that the user clicks on. Stop link event propagation.
       *
       * @param {MouseEvent} event
       */
      function linkClick(event) {
        if (event.target.innerHTML == 'Home' || event.target.innerHTML == 'Shows' || event.target.innerHTML == 'Movies') {
          return true;
        }
        else {
          event.preventDefault();
          chooseOverlay(event);
          const data = event.target.getAttribute('href');
          const url = data + '/';
          history.pushState(data, null, url);
          document.title = event.target.innerText + ' Channel';
          event.stopPropagation();
        }
      } // end linkClick function

      /**
       * onYouTubeIframeAPIReady function (Google code: https://developers.google.com/youtube/iframe_api_reference)
       *
       * Automatically runs when the YouTube API is ready. It needs to be in the global scope (window.) so API can access it.
       *
       * Check to see if the playerInfoList object has been created. If not, return.
       *
       * Loop through each element in the playerInfoList object, create player from that info,
       * populate the players array with each player, and hide each player in the DOM.
       */
      window.onYouTubeIframeAPIReady = function() {
        if (typeof playerInfoList === 'undefined') return;
        for (let i = 0, listLength = playerInfoList.length; i < listLength; i++) {
          let currentPlayer = createPlayer(playerInfoList[i]);
          players[i] = currentPlayer;
          document.getElementById(players[i].f.id).setAttribute('hidden', '');
        }
      }

      /**
       * pausePlayers function
       *
       * Called from the close function, the popstate event listener, and the beforeunload event listener.
       *
       * Loops through all of the players, pauses, and hides each player.
       */
      function pausePlayers() {
        for (let i = 0, playersLength = players.length; i < playersLength; i++) {
          players[i].pauseVideo();
          players[i].f.setAttribute('hidden', '');
        }
      }

      /**
       * populateChannelStorage function
       *
       * Called by the init function and the toggleButtonState function.
       *
       * Loop through all of the channel rows. Populate local storage with the channel name and favorite icon. Also save
       * aria-pressed state and the channel filter.
       *
       * Sets the channel styles on their respective components by calling setChannelStyles function.
       */
      function populateChannelStorage() {
        for (let i = 0, favLength = FAVORITES.length; i < favLength; i++) {
          const channel = CHANNEL_NAMES[i].innerText.replace(/\s/g,'');
          localStorage.setItem(channel, FAVORITES[i].innerText);
          localStorage.setItem(channel+'Pressed', FAVORITES[i].getAttribute('aria-pressed'));
          localStorage.setItem(channel+'Filter', FAVORITES[i].parentElement.classList[0]);
        }
        setChannelStyles();
      }

      /**
       * populateFilterStorage function
       *
       * Called by the init fuction and filterClick function.
       *
       * If no filter is checked (likely on user's first visit), set the filter to all channels.
       *
       * Loop through the filters and whichever is checked, populate local storage with that filter.
       *
       * Set the filter styles on the page by calling setFilterStyles function.
       */
      function populateFilterStorage() {
        if (FILTERS[0].checked === false && FILTERS[1].checked === false){
          FILTERS[0].setAttribute('checked', '');
        }
        for (let i = 0, filtersLength = FILTERS.length; i < filtersLength; i++){
          if (FILTERS[i].checked) {
            localStorage.setItem('FilterSelected', FILTERS[i].value);
          }
        }
        setFilterStyles();
      }

      /**
       * populateSearchStorage function
       *
       * Called by the init function and the search function.
       *
       * Populate local storage with the value that is in the search field.
       *
       * Set the search field value to the value that is saved in the local storage by calling setSearchValue function.
       */
      function populateSearchStorage() {
        localStorage.setItem('SearchValue', SEARCH.value);
        setSearchValue();
      }

      /**
       * search function
       *
       * Called by the init function and the SEARCH event listener.
       *
       * Called when the page is loaded, every time the user presses a key in the search field, and when
       * the X is clicked in the search field.
       *
       * Populates the local storage with the value in the search field by calling populateSearchStorage.
       *
       * Converts any alpha character to upper case. If the filter is set to favorite channels, collect all of
       * the favorite table rows and hide the empty query paragraph. Otherwise get all of the table rows. Set
       * a counter for hidden rows and loop through all of the table rows.
       *
       * If the value in the search field matches any of the part of the displayed channels,
       * show those channels to the user and hide the empty query paragraph.
       *
       * Otherwise, hide the table row and add one to the hidden row counter. If the hidden row counter equals
       * the total number of rows then hide the whole table and show the empty query paragraph.
       *
       * @param {KeyboardEvent, SearchEvent} event
       */
      function search(event) {
        populateSearchStorage();
        let channelLink, cName, hiddenRowCount, searchValue, tr;
        searchValue = SEARCH.value.toUpperCase();
        if (FILTERS[1].checked === true) {
          tr = document.getElementsByClassName('favorites');
          EMPTY_QUERY.setAttribute('hidden', '');
        }
        else {
          tr = document.getElementsByTagName('tr');
        }
        hiddenRowCount = 0;
        for (let i = 0, trLength = tr.length; i < trLength; i++) {
          channelLink = CHANNEL_NAMES[i].getElementsByTagName('a');
          cName = channelLink[0].innerText;
          if (cName.toUpperCase().indexOf(searchValue) > -1) {
            TABLE.removeAttribute('hidden');
            tr[i].removeAttribute('hidden');
            EMPTY_QUERY.setAttribute('hidden', '');
          }
          else {
            tr[i].setAttribute('hidden', '');
            hiddenRowCount++;
            if (hiddenRowCount === tr.length) {
              TABLE.setAttribute('hidden', '');
              EMPTY_QUERY.removeAttribute('hidden');
            } // end if
          }
        } // end loop
      } // end search function

      /**
       * setChannelStyles function
       *
       * Called by the init function and the populateChannelStorage function.
       *
       * Loops through all of the channel rows and sets the styles of all the channels based on their values
       * in local storage (channel icon, filter, and aria-pressed values).
       */
      function setChannelStyles() {
        let channelIcons = [];
        let rowFilters = [];
        let arias = [];
        for (let i = 0, favLength = FAVORITES.length; i < favLength; i++) {
          const channel = CHANNEL_NAMES[i].innerText.replace(/\s/g,'');
          channelIcons[i] = localStorage.getItem(channel);
          rowFilters[i] = localStorage.getItem(channel+'Filter');
          arias[i] = localStorage.getItem(channel+'Pressed');
          FAVORITES[i].innerText = channelIcons[i];
          FAVORITES[i].parentElement.classList = rowFilters[i];
          FAVORITES[i].setAttribute('aria-pressed', arias[i]);
        }
      }

      /**
       * setFilterStyles function
       *
       * Called by the init function and the populateFilterStorage function.
       *
       * Sets the style of the filter on the page based on the filter value saved in local storage. If the filter is set to 
       * favorite channels, displays the favorite channels by calling the filterFavorites function.
       */
      function setFilterStyles() {
        let filterChecked = localStorage.getItem('FilterSelected');
        if (filterChecked === 'all') {
          FILTERS[0].checked = true;
          FILTERS[0].setAttribute('checked', '');
        }
        else {
          FILTERS[1].checked = true;
          FILTERS[1].setAttribute('checked', '');
          filterFavorites();
        }
      }

      /**
       * setSearchValue function
       *
       * Called by the init function and the populateSearchStorage function.
       * 
       * Sets the search field value on the page to the search value that is saved in local storage.
       */
      function setSearchValue() {
        let savedSearch = localStorage.getItem('SearchValue');
        SEARCH.value = savedSearch;
      }

      /**
       * showOverlay function
       *
       * Called by chooseOverlay function.
       *
       * Hide the main and nav elements, show the overlay, populate the overlay H1 with the channel title parameter
       * being sent, show the appropriate player based on the player parameter being sent, start playing the video, and
       * set the current player index local storage value to the player being played index.
       *
       * @param {Integer} playerIndex, {String} channelTitle
       */
      function showOverlay(playerIndex, channelTitle) {
        MAIN.setAttribute('hidden', '');
        NAV.setAttribute('hidden', '');
        OVERLAY.removeAttribute('hidden');
        OVERLAY_TITLE.innerText = channelTitle;
        players[playerIndex].f.removeAttribute('hidden');
        players[playerIndex].playVideo();
        localStorage.setItem('CurrentPlayerIndex', playerIndex);
      }

      /**
       * tdClick function
       *
       * Called by the CHANNEL_NUMBERS and CHANNEL_NAMES event listener.
       *
       * Allows whole table cell to be clicked or touched and goes to the link in the anchor tag.
       *
       * @param {MouseEvent} event
       */
      function tdClick(event) {
        location.href = this.querySelector('a').href;
      }

      /**
       * toggleButtonClickHandler function
       *
       * Called by the FAVORITES click event listener.
       *
       * Whenever the user clicks on a favorite icon, check if the event target has a button role, toggle it's state
       * by calling toggleButtonState function.
       *
       * @param {MouseEvent} event
       */
      function toggleButtonClickHandler(event) {
        if (event.currentTarget.getAttribute('role') === 'button') {
          toggleButtonState(event.currentTarget);
        }
      }

      /**
       * toggleButtonKeydownHandler function
       *
       * Called by the ALL_LABEL, FAVORITE_LABEL, and FAVORITES keydown event listener.
       *
       * Whenever the user keys down on a toggle button, toggle the state. Prevents default actions of
       * pressing space and enter keys.
       *
       * If keydown is space, prevent default and ignore it. If keydown is enter, toggle the favorite icon by calling
       * the toggleButtonState function.
       *
       * @param {KeyboardEvent} event
       */
      function toggleButtonKeydownHandler(event) {
        if (event.keyCode === 32) {
          event.preventDefault();
        }
        else if (event.keyCode === 13) {
          event.preventDefault();
          toggleButtonState(event.currentTarget);
        }
      }

      /**
       * toggleFilterKeydownHandler function
       *
       * Called by the FILTERS keydown event listener.
       *
       * Toggles the channel filter based on the keydown event fired.
       *
       * If keydown is space, prevent the default action and ignore it.
       *
       * If the keydown event is the enter key, filter the channel list based on that event by calling the filterClick
       * function.
       *
       * If key down is any of the four arrow keys, reverse the label and filter the channel list based on that
       * reversed label by calling the filterClick function with that parameter.
       *
       * @param {KeyboardEvent} event
       */
       function toggleFilterKeydownHandler(event) {
         if (event.keyCode === 32) {
           event.preventDefault();
         }
         else if (event.keyCode === 13) {
           event.preventDefault();
           filterClick(event.currentTarget);
         }
         else if (event.keyCode > 36 && event.keyCode < 41) {
           let reverseLabel = (event.currentTarget.htmlFor === 'all') ? FAVORITE_LABEL : ALL_LABEL;
           filterClick(reverseLabel);
         }
       }

      /**
       * toggleButtonKeyupHandler function
       *
       * Called by the ALL_LABEL, FAVORITE_LABEL, and FAVORITES keyup event listener.
       *
       * If the space bar is pressed, prevent the default action and check what event was fired. If the user 
       * pressed the key on the channel filter, filter the channels.
       *
       * Otherwise the key was pressed on the favorite toggle so it can be toggled.
       *
       * @param {KeyboardEvent} event
       */
      function toggleButtonKeyupHandler(event) {
        if (event.keyCode === 32) {
          event.preventDefault();
          if (event.currentTarget === ALL_LABEL || event.currentTarget === FAVORITE_LABEL) {
            filterClick(event.currentTarget);
          }
          else toggleButtonState(event.currentTarget);
        }
      }

      /**
       * toggleButtonState function
       *
       * Called by the toggleButtonClickHandler function, the toggleButtonKeydownHandler function, and the
       * toggleButtonKeyupHandler function.
       *
       * Toggles the toggle button's state between pressed and not pressed. If filter selected is favorites and the
       * icon for the channel is not a favorite, call the filterFavorites function.
       *
       * Populate the channel storage by calling the populateChannelStorage function.
       *
       * @param {HTMLElement} button
       */
      function toggleButtonState(button) {
        const filterSelected = localStorage.getItem('FilterSelected');
        const isAriaPressed = button.getAttribute('aria-pressed') === 'true';
        button.setAttribute('aria-pressed', isAriaPressed ? 'false' : 'true');
        button.innerText = (isAriaPressed === true) ? '♡' : '❤️';
        button.parentElement.classList = (isAriaPressed === true) ? 'all' : 'favorites';
        if (filterSelected === 'favorites' && button.innerText === '♡') {
          filterFavorites();
        }
        populateChannelStorage();
      }

    })();
    </script>

    <!-- For users who have javascript turned off -->
    <noscript>
      <style>
        body {
          margin: 10px;
        }
        main, nav {
          display: none;
        }
        div {
          border: 1px solid black;
          margin: 0 auto;
          max-width: 450px;
          padding: 10px
        }
      </style>
      <div>
        <p>Hey, it looks like you have JavaScript turned off.</p>
        <p>Here's how to <a href="https://www.google.com/search?q=turn+on+javascript">turn on JavaScript</a>.</p>
        <p>If you purposely want it off, this app is very dependent on YouTube which needs JavaScript to run.</p>
        <p>You can just <a href="https://www.youtube.com/channel/UCd1sfSmij8b-w7wP_7IPvSA/playlists?feature=guide&view=1">go to YouTube</a> and check out all our playlists there. Enjoy!<p>
      </div>
    </noscript>

  </body>
</html>
