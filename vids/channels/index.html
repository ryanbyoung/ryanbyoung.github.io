<!doctype html> 
<!-- TODO When you add script to app, don't forget playerInfoList variable on this line **** -->
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0" name="viewport">
    <title>Channels</title>
    <style>
      body {
        background-color: #000;
        color: #fff;
        font-size: 20px;
        margin: 0
      }
      main {
        margin: 0 auto;
        max-width: 700px;
        padding: 0 10px 70px;
        position: relative;
        z-index: 1
      }
      h1, p {
        text-align: center
      }
      a, a:visited {
        color: #fff
      }
      #search {
        -webkit-appearance: none;
        -webkit-border-radius:0;
        background-color: #000;
        border: solid #fff 1px;
        border-radius:0;
        color: #fff;
        font-family: serif;
        font-size: 20px;
        padding: 6px;
        width: 175px
      }
      #search::placeholder {
        font-family: serif;
        font-size: 20px
      }
      input[type="search"]::-webkit-search-cancel-button {
        -webkit-appearance: none;
        background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAn0lEQVR42u3UMQrDMBBEUZ9WfQqDmm22EaTyjRMHAlM5K+Y7lb0wnUZPIKHlnutOa+25Z4D++MRBX98MD1V/trSppLKHqj9TTBWKcoUqffbUcbBBEhTjBOV4ja4l4OIAZThEOV6jHO8ARXD+gPPvKMABinGOrnu6gTNUawrcQKNCAQ7QeTxORzle3+sDfjJpPCqhJh7GixZq4rHcc9l5A9qZ+WeBhgEuAAAAAElFTkSuQmCC);
        background-repeat: no-repeat;
        background-size: 20px;
        cursor: pointer;
        display: block;
        height: 20px;
        width: 20px
      }
      fieldset {
        border: 0;
        margin: 1em 0;
        padding: 0;
        text-align: center
      }
      legend, input[type="radio"] {
        border: 0;
        clip: rect(1px, 1px, 1px, 1px);
        height: 1px;
        margin: -1px;
        overflow: hidden;
        padding: 0;
        position: absolute;
        width: 1px;
      }
      input[type="radio"]:checked + label {
        text-decoration: underline
      }
      fieldset label {
        cursor: pointer
      }
      fieldset label:last-child {
        margin-left: 20px
      }
      table {
        border-collapse: collapse;
        border-spacing: 0px;
        margin: 0 auto
      }
      td {
        border-bottom: 1px solid #303030;
        border-right: 0;
        cursor: pointer;
        height: 36px;
        padding: 5px 12px
      }
      td a {
        text-decoration: none
      }
      .favorite, .channel-number {
        text-align: center;
        width: 30px
      }
      .search-item {
        padding: 5px 20px
      }
      nav {
        background-color: #303030;
        bottom: 0;
        position: fixed;
        text-align: center;
        width: 100%;
        z-index: 1
      }
      nav p {
        margin: 10px auto;
        max-width: 700px
      }
      nav a:hover {
        color: red
      }
      .embed-container {
        height: 0;
        padding-bottom: 56.25%;
        position: relative
      }
      .embed-container iframe {
        height: 100%;
        left: 0;
        position: absolute;
        top: 0;
        width: 100%
      }
      #overlay {
        padding-bottom: 0
      }
      #overlay-title {
        font-size: 1.5em;
        margin: .83em 0
      }
      #close {
        background-color: #000;
        border: 2px solid #fff;
        color: #fff;
        font: 20px serif;
        line-height: 2.5;
        margin-top: 30px;
        padding: 0 20px
      }
    </style>
  </head>
  <body>
    <main>
      <h1>Channels</h1>
      <p>
        <label for="search">Search:</label>
        <input aria-label="Search channels" id="search" name="search" placeholder="Dane, Kelly, etc." type="search">
      </p>
      <fieldset>
        <legend>Filter</legend>
        <input id="all" name="filter" tabindex="-1" type="radio" value="all">
        <label for="all" tabindex="0">All Channels</label>
        <input id="favorites" name="filter" tabindex="-1" type="radio" value="favorites">
        <label for="favorites" tabindex="0">Favorite Channels</label>
      </fieldset>
      <table>
        <tbody>
          <tr class="all">
            <td aria-label="Favorite channel" aria-pressed="false" class="favorite" role="button" tabindex="0">♡</td>
            <td class="channel-number">
              <a href="dane-reynolds">1</a>
            </td>
            <td class="channel-name">
              <a href="dane-reynolds">Dane Reynolds</a>
            </td>
          </tr>
          <tr class="all">
            <td aria-label="Favorite channel" aria-pressed="false" class="favorite" role="button" tabindex="0">♡</td>
            <td class="channel-number">
              <a href="kelly-slater">2</a>
            </td>
            <td class="channel-name">
              <a href="kelly-slater">Kelly Slater</a>
            </td>
          </tr>
          <tr class="all">
            <td aria-label="Favorite channel" aria-pressed="false" class="favorite" role="button" tabindex="0">♡</td>
            <td class="channel-number">
              <a href="craig-anderson">3</a>
            </td>
            <td class="channel-name">
              <a href="craig-anderson">Craig Anderson</a>
            </td>
          </tr>
        </tbody>
      </table>
      <p id="empty-query" hidden>No channels exist that match your query.</p>
      <p id="empty-filter" hidden>No favorite channels have been selected.</p>
    </main>
    <main id="overlay" hidden>
      <h1 id="overlay-title"></h1>
      <div class="embed-container">
        <div id="DaneReynoldsPlayer"></div>
        <div id="KellySlaterPlayer"></div>
        <div id="CraigAndersonPlayer"></div>
      </div>
      <p>
        <button id="close">Close Channel</button>
      </p>
    </main>
    <nav>
      <p>
        <a href="..">Home</a> &nbsp;|&nbsp;
        Channels &nbsp;|&nbsp;
        <a href="../shows/">Shows</a> &nbsp;|&nbsp;
        <a href="../movies/">Movies</a>
      </p>
    </nav>

    <script src="https://www.youtube.com/iframe_api"></script>
    <script>
    (function(){

      /* The playerInfoList object containing info for all of the players
       * (this probably can be pulled dynamically from the data file in the app so probably won't be needed)
       */
      const playerInfoList = [{
        length: 60,
        playlist: 'PLMxOsrgGH8n5HGL-UjsVoRQnemeWRcwkx',
        playlistName: 'DaneReynolds'
      }, {
        length: 6,
        playlist: 'PLMxOsrgGH8n49WElPVU1isa7ifuUkZFMf',
        playlistName: 'KellySlater'
      }, {
        length: 4,
        playlist: 'PLMxOsrgGH8n622jc8CpXksExjvI0z6Cxy',
        playlistName: 'CraigAnderson'
      }];

      const ALL_LABEL = document.querySelector('label[for=all]');
      const BODY = document.querySelector('body');
      const CHANNEL_NAMES = document.querySelectorAll('.channel-name');
      const CHANNEL_NUMBERS = document.querySelectorAll('.channel-number');
      const CLOSE = document.getElementById('close');
      const EMPTY = '';
      const EMPTY_FILTER = document.getElementById('empty-filter');
      const EMPTY_QUERY = document.getElementById('empty-query');
      const FAVORITE_LABEL = document.querySelector('label[for=favorites]');
      const FAVORITES = document.querySelectorAll('.favorite');
      const FILTERS = document.querySelectorAll('input[name=filter]');
      const LINKS = document.querySelectorAll('a');
      const MAIN = document.querySelector('main');
      const NAV = document.querySelector('nav');
      const OVERLAY = document.getElementById('overlay');
      const OVERLAY_TITLE = document.getElementById('overlay-title');
      const PAGE_TITLE = 'Channels';
      let players = new Array();
      const SEARCH = document.querySelector('#search');
      const TABLE = document.querySelector('table');
      const TABLE_ROWS = document.getElementsByTagName('tr');
      
      /**
       * close function
       *
       * Runs when close channel button is pressed.
       *
       * Builds fullURL for history. Calls pausePlayers and hideOverlay functions. Pushes URL to history state.
       */
      function close() {
        const pathArray = window.location.pathname.split('/');
        let fullURL = window.location.protocol + "//" + window.location.host;
        for (let i = 0; i < 3; i++) {
          fullURL += pathArray[i];
          fullURL += "/";
        }
        pausePlayers();
        hideOverlay();
        history.pushState(null, null, fullURL);
      }

      /**
       * createPlayer function
       *
       * Called from onYouTubeIframeAPIReady function.
       *
       * Creates a YouTube player for each channnel.
       *
       * Create variables for player name and local storage (playlist, playlist index, and player time.
       *
       * Create each player with the player name, height and width of player (100% for responsive), and events.
       * 
       * The onReady event fires when each player is ready. It first checks if there is a playlist for the player
       * in local storage. If it does, it retrieves the playlist, index, and time for that player and cues the playlist.
       * It also sets the playlist to loop. If the player isn't found in local storage, it creates a random number
       * based on the number of videos in the playlist to decide which video to play first and creates a new playlist.
       * A second after the playlist is created, it is set to shuffle all of the videos in the playlist. It is also set 
       * to loop the playlist.
       *
       * The onStateChange event updates all of the local storage items (playlist, index, and time) whenever the player is
       * paused (event.data = 2).
       *
       * @param {Object} playerInfo
       */
      function createPlayer(playerInfo) {
        const playerName = playerInfo.playlistName + 'Player';
        const playerPlaylist = playerInfo.playlistName + 'Playlist';
        const playerPlaylistIndex = playerInfo.playlistName + 'PlaylistIndex';
        const playerTime = playerInfo.playlistName + 'IndexTime';
        return new YT.Player(playerName, {
          height: '100%',
          width: '100%',
          events: {
            'onReady': function(event) {
              // Check if there is a playlist for this player in local storage
              if (localStorage.getItem(playerPlaylist) != null) {
                event.target.cuePlaylist(
                  localStorage.getItem(playerPlaylist),
                  localStorage.getItem(playerPlaylistIndex),
                  localStorage.getItem(playerTime)
                );
                event.target.setLoop(true);
              }
              else {
                let index = Math.floor((Math.random() * playerInfo.length) + 1);
                event.target.cuePlaylist({
                  listType:'playlist',
                  list:playerInfo.playlist,
                  index:index
                });
                setTimeout(function() {
                  event.target.setShuffle({'shufflePlaylist' : true});
                }, 1000);
                event.target.setLoop(true); 
              }
            }, // end onReady event
            'onStateChange': function(event) {
              if (event.data === 2) {
                localStorage.setItem(playerPlaylist, event.target.getPlaylist());
                localStorage.setItem(playerPlaylistIndex, event.target.getPlaylistIndex());
                localStorage.setItem(playerTime, event.target.getCurrentTime());
              }
            } // end onStateChange event
          } // end events
        }); // end return
      } // end createPlayer function

      /**
       * filterAll function
       *
       * Called by filterClick function.
       *
       * If search field isn't empty, loop through all table rows. If the channel
       * name matches what's in the search field, remove the hidden attribute on the table and all of it's rows,
       * and hide the empty query element. Ottherwise, hide all of the table rows and increase the hidden row
       * counter. If the counter equals the total number of table rows, hide the table and show the empty query
       * element.
       *
       * If the search field is empty, hide the empty filter element, show the table and all of it's rows.
       */
      function filterAll() {
        const searchValue = SEARCH.value.toUpperCase();
        if (searchValue !== EMPTY) {
          let hiddenRowCount = 0;
          for (let i = 0, trLength = TABLE_ROWS.length; i < trLength; i++) {
            const channelLink = CHANNEL_NAMES[i].getElementsByTagName('a');
            const cName = channelLink[0].innerText;
            if (cName.toUpperCase().indexOf(searchValue) > -1) {
              TABLE.removeAttribue('hidden');
              TABLE_ROWS[i].removeAttribute('hidden');
              EMPTY_QUERY.setAttribute('hidden', '');
            }
            else {
              TABLE_ROWS[i].setAttribute('hidden', '');
              hiddenRowCount++;
              if (hiddenRowCount === TABLE_ROWS.length) {
                TABLE.setAttribute('hidden', '');
                EMPTY_QUERY.removeAttribute('hidden');
              }
            }
          } // end loop
        }
        else {
          EMPTY_FILTER.setAttribute('hidden', '');
          TABLE.removeAttribute('hidden');
          for (let j = 0, trLength = TABLE_ROWS.length; j < trLength; j++) {
            TABLE_ROWS[j].removeAttribute('hidden');
          }
        }
      } // end filterAll function

      /**
       * filterClick function
       * 
       * Runs when user interacts with the channel filter (by click or keyboard).
       *
       * Update document with selection.
       *
       * Populate filter information in local storage.
       *
       * Filter the document content according to the incoming channel filter.
       *
       * @param {KeyboardEvent} event
       */
      function filterClick(event) {
        if (this.value === 'favorites' || event.htmlFor === 'favorites') {
          FILTERS[0].removeAttribute('checked');
          FILTERS[1].setAttribute('checked', '');
          FILTERS[1].checked = true;
          populateFilterStorage();
          filterFavorites();
        }
        else {
          FILTERS[0].setAttribute('checked', '');
          FILTERS[0].checked = true;
          ALL_LABEL.focus();
          FILTERS[1].removeAttribute('checked');
          EMPTY_FILTER.setAttribute('hidden', '');
          populateFilterStorage();
          filterAll();
        }
      } // end filterClick function

      /**
       * filterFavorites function
       *
       * When filter is set to favorite channels, focus on the filter and hide rows that
       * have the all channels filter on them.
       *
       * If no favorites are selected, hide the whole table and show the empty
       * filter paragraph.
       */
      function filterFavorites() {
        FAVORITE_LABEL.focus();
        let allOnlyRows = document.querySelectorAll('.all');
        for (let i = 0, allLength = allOnlyRows.length; i < allLength; i++) {
          allOnlyRows[i].setAttribute('hidden', '');
        }
        if (allOnlyRows.length === playerInfoList.length) { // **** make sure you change this variable for prod
          TABLE.setAttribute('hidden', '');
          EMPTY_FILTER.removeAttribute('hidden');
        }
      }

      /**
       * hideOverlay function
       *
       * Called by close function. Unhides the main and nav elements. Hides the overlay element, removes the text
       * for the overlay H1, and sets the title of the page back to Channels.
       */
      function hideOverlay() {
        MAIN.removeAttribute('hidden');
        NAV.removeAttribute('hidden');
        OVERLAY.setAttribute('hidden', '');
        OVERLAY_TITLE.innerText = '';
        document.title = PAGE_TITLE;
      }

      /**
       * init function
       *
       * Runs everytime the page is loaded.
       *
       * Checks to see if local storage exists for channel, filter, or search components. 
       * If that information isn't in local storage, it populates it with what is currently on the page. 
       * If local storage exists, it sets up the page with components from the information in local storage.
       *
       * If the user left anything in the search field, it runs the search function.
       *
       * It then adds event listeners for all of the components (search, filter labels, and table elements).
       */
      function init() {
        if (localStorage.length === 0) {
          populateChannelStorage();
          populateFilterStorage();
          populateSearchStorage();
        } else {
          setChannelStyles();
          setFilterStyles();
          setSearchValue();
        }
        if (SEARCH.value !== EMPTY) {
          search();
        }
        ALL_LABEL.addEventListener('keydown', toggleFilterKeydownHandler, false);
        ALL_LABEL.addEventListener('keyup', toggleButtonKeyupHandler, false);
        CLOSE.addEventListener('click', close, false);
        for (let i = 0, namesLength = CHANNEL_NAMES.length; i < namesLength; i++) {
          CHANNEL_NAMES[i].addEventListener('click', tdClick, false);
          CHANNEL_NUMBERS[i].addEventListener('click', tdClick, false);
          FAVORITES[i].addEventListener('click', toggleButtonClickHandler, false);
          FAVORITES[i].addEventListener('keydown', toggleButtonKeydownHandler, false);
          FAVORITES[i].addEventListener('keyup', toggleButtonKeyupHandler, false);
        }
        FAVORITE_LABEL.addEventListener('keydown', toggleFilterKeydownHandler, false);
        FAVORITE_LABEL.addEventListener('keyup', toggleButtonKeyupHandler, false);
        for (let j = 0, filtersLength = FILTERS.length; j < filtersLength; j++) {
          FILTERS[j].addEventListener('click', filterClick, false);
        }
        for (let k = 0, linksLength = LINKS.length; k < linksLength ; k++) {
          LINKS[k].addEventListener('click', linkClick, false);
        }
        SEARCH.addEventListener('keyup', search, false);
        SEARCH.addEventListener('search', search, false);
      } // end init function

      /**
       * linkClick function
       *
       *
       * @param {MouseEvent} event
       */
      function linkClick(event) {
        // Handle clicks on nav links with the default action
        if (event.target.innerHTML == 'Home' || event.target.innerHTML == 'Shows' || event.target.innerHTML == 'Movies') {
          return true;
        }
        else {
          event.preventDefault();
          switch (event.target.innerHTML) {
            case '1':
            case 'Dane Reynolds':
              showOverlay(0, 'Dane Reynolds Channel');
              break;
            case '2':
            case 'Kelly Slater':
              showOverlay(1, 'Kelly Slater Channel');
              break;
            case '3':
            case 'Craig Anderson':
              showOverlay(2, 'Craig Anderson Channel');
              break;
            default:
              showOverlay(0, 'Dane Reynolds Channel');
          }
          const data = event.target.getAttribute('href');
          const url = data + '/';
          history.pushState(data, null, url);
          event.stopPropagation();
        }
      } // end linkClick function

      /**
       * onYouTubeIframeAPIReady function (Google code: https://developers.google.com/youtube/iframe_api_reference)
       *
       * Automatically runs when the YouTube API is ready. It needs to be in the global scope (window.) so API can access it.
       *
       * Check to see if the playerInfoList object has been created. If not, return.
       *
       * Loop through each element in the playerInfoList object, create player from that info,
       * populate the players array with each player, and hide each player in the DOM.
       */
      window.onYouTubeIframeAPIReady = function() {
        if (typeof playerInfoList === 'undefined') return;
        for (let i = 0, listLength = playerInfoList.length; i < listLength; i++) {
          let currentPlayer = createPlayer(playerInfoList[i]);
          players[i] = currentPlayer;
          document.getElementById(players[i].f.id).setAttribute('hidden', '');
        }
        console.log(players);
      }

      /**
       * pausePlayers function
       *
       * Called from close function. Loops through all of the players then pauses and hides each one.
       */
      function pausePlayers() {
        for (let i = 0, playersLength = players.length; i < playersLength; i++) {
          players[i].pauseVideo();
          players[i].f.setAttribute('hidden', '');
        }
      }

      /**
       * populateChannelStorage function
       *
       * Populate local storage with the id of the channel when the favorite
       * icon is pressed. Also save whether the icon is pressed and the channel filter.
       * Set the channel styles on their respective componets.
       */
      function populateChannelStorage() {
        for (let i = 0, favLength = FAVORITES.length; i < favLength; i++) {
          const channel = CHANNEL_NAMES[i].innerText.replace(/\s/g,'');
          localStorage.setItem(channel, FAVORITES[i].innerText);
          localStorage.setItem(channel+'Pressed', FAVORITES[i].getAttribute('aria-pressed'));
          localStorage.setItem(channel+'Filter', FAVORITES[i].parentElement.classList[0]);
        }
        setChannelStyles();
      }

      /**
       * populateFilterStorage function
       *
       * If no filter is checked (likely on user's first visit), set the filter to all channels.
       * Populate local storage with the channel filter that is selected.
       */
      function populateFilterStorage() {
        if (FILTERS[0].checked === false && FILTERS[1].checked === false){
          FILTERS[0].setAttribute('checked', '');
        }
        for (let i = 0, filtersLength = FILTERS.length; i < filtersLength; i++){
          if (FILTERS[i].checked) {
            localStorage.setItem('FilterSelected', FILTERS[i].value);
          }
        }
        setFilterStyles();
      }

      /**
       * populateSearchStorage function
       *
       * Populate local storage with the value that is in the search field.
       * Sets the search field value to the value that is saved in the local storage.
       */
      function populateSearchStorage() {
        localStorage.setItem('SearchValue', SEARCH.value);
        setSearchValue();
      }

      /**
       * search function
       *
       * Called from init when the page is loaded, every time the user presses a key in the search field, and when
       * the X is clicked in the search field.
       *
       * Populates the local storage with the value in the search field.
       *
       * Converts any alpha character to upper case. If filter is set to favorite channels,
       * collect all of the favorited table rows and hid the empty query paragraph.
       * Otherwise get all of the table rows. Set a counter for hidden rows
       * and loop through all of the table rows.
       *
       * If the value in the search field matches any of the part of the displayed channels,
       * show those channels to the user and hide the empty query paragraph.
       *
       * Otherwise, hide the table row and add one to the hidden row counter.
       * If the hidden row counter equals the total number of rows than hide the whole table
       * and show the empty query paragraph.
       *
       * @param {KeyboardEvent, SearchEvent} event
       */
      function search(event) {
        console.log(event);
        populateSearchStorage();
        let channelLink, cName, hiddenRowCount, searchValue, tr;
        searchValue = SEARCH.value.toUpperCase();
        if (FILTERS[1].checked === true) {
          tr = document.getElementsByClassName('favorites');
          EMPTY_QUERY.setAttribute('hidden', '');
        }
        else {
          tr = document.getElementsByTagName('tr');
        }
        hiddenRowCount = 0;
        for (let i = 0, trLength = tr.length; i < trLength; i++) {
          channelLink = CHANNEL_NAMES[i].getElementsByTagName('a');
          cName = channelLink[0].innerText;
          if (cName.toUpperCase().indexOf(searchValue) > -1) {
            TABLE.removeAttribute('hidden');
            tr[i].removeAttribute('hidden');
            EMPTY_QUERY.setAttribute('hidden', '');
          }
          else {
            tr[i].setAttribute('hidden', '');
            hiddenRowCount++;
            if (hiddenRowCount === tr.length) {
              TABLE.setAttribute('hidden', '');
              EMPTY_QUERY.removeAttribute('hidden');
            }
          }
        }
      } // end search function

      /**
       * setChannelStyles function
       *
       * Sets the styles of all the channels based on their values in local storage.
       */
      function setChannelStyles() {
        let channelIcons = [];
        let rowFilters = [];
        let arias = [];
        for (let i = 0, favLength = FAVORITES.length; i < favLength; i++) {
          const channel = CHANNEL_NAMES[i].innerText.replace(/\s/g,'');
          channelIcons[i] = localStorage.getItem(channel);
          rowFilters[i] = localStorage.getItem(channel+'Filter');
          arias[i] = localStorage.getItem(channel+'Pressed');
          FAVORITES[i].innerText = channelIcons[i];
          FAVORITES[i].parentElement.classList = rowFilters[i];
          FAVORITES[i].setAttribute('aria-pressed', arias[i]);
        }
      }

      /**
       * setFilterStyles function
       *
       * Sets the style of the filter based on the values saved in local storage.
       * If the filter is set to favorite channels, displays the favorite channels.
       */
      function setFilterStyles() {
        let filterChecked = localStorage.getItem('FilterSelected');
        if (filterChecked === 'all') {
          FILTERS[0].checked = true;
          FILTERS[0].setAttribute('checked', '');
        }
        else {
          FILTERS[1].checked = true;
          FILTERS[1].setAttribute('checked', '');
          filterFavorites();
        }
      }

      /**
       * setSearchValue function
       * 
       * Sets the search field value to the value that is saved in local storage.
       */
      function setSearchValue() {
        let savedSearch = localStorage.getItem('SearchValue');
        SEARCH.value = savedSearch;
      }

      /**
       * showOverlay function
       *
       * @param
       */
      function showOverlay(playerIndex, channelTitle) {
        MAIN.setAttribute('hidden', '');
        OVERLAY.removeAttribute('hidden');
        OVERLAY_TITLE.innerText = channelTitle;
        players[playerIndex].f.removeAttribute('hidden');
        players[playerIndex].playVideo();
        document.title = channelTitle;
        NAV.setAttribute('hidden', '');
      }

      /**
       * tdClick function
       *
       * Allows whole table cell to be clicked or touched and goes to the link in the
       * anchor tag.
       *
       * @param {MouseEvent} event
       */
      function tdClick(event) {
        location.href = this.querySelector('a').href;
      }

      /**
       * toggleButtonClickHandler function
       *
       * If the event target has a button role, toggle it's state.
       *
       * @param {MouseEvent} event
       */
      function toggleButtonClickHandler(event) {
        if (event.currentTarget.getAttribute('role') === 'button') {
          toggleButtonState(event.currentTarget);
        }
      }

      /**
       * toggleButtonKeydownHandler function
       *
       * Toggles the toggle button's state on key down. Prevents default actions of
       * space and enter keys.
       *
       * If keydown is space, prevent default and ignore it. If keydown is enter,
       * toggle the favorite icon.
       *
       * @param {KeyboardEvent} event
       */
      function toggleButtonKeydownHandler(event) {
        if (event.keyCode === 32) {
          event.preventDefault();
        }
        else if (event.keyCode === 13) {
          event.preventDefault();
          toggleButtonState(event.currentTarget);
        }
      }

      /**
       * toggleFilterKeydownHandler function
       *
       * Toggles the channel filter based on the keydown event fired.
       *
       * If keydown is space, prevent the default action and ignore it.
       *
       * If the keydown event is the enter key, filter the channel list based on that event.
       *
       * If key down is any of the four arrow keys, reverse the label and filter the
       * channel list based on that reversed label.
       *
       * @param {KeyboardEvent} event
       */
       function toggleFilterKeydownHandler(event) {
         if (event.keyCode === 32) {
           event.preventDefault();
         }
         else if (event.keyCode === 13) {
           event.preventDefault();
           filterClick(event.currentTarget);
         }
         else if (event.keyCode > 36 && event.keyCode < 41) {
           let reverseLabel = (event.currentTarget.htmlFor === 'all') ? FAVORITE_LABEL : ALL_LABEL;
           filterClick(reverseLabel);
         }
       }

      /**
       * toggleButtonKeyupHandler function
       *
       * If the space bar is pressed, prevent the default action and check what event
       * was fired. If the user pressed it on the channel filter, filter the channels.
       *
       * Otherwise it was pressed on the favorite toggle so it can be toggled.
       *
       * @param {KeyboardEvent} event
       */
      function toggleButtonKeyupHandler(event) {
        if (event.keyCode === 32) {
          event.preventDefault();
          if (event.currentTarget === ALL_LABEL || event.currentTarget === FAVORITE_LABEL) {
            filterClick(event.currentTarget);
          }
          else toggleButtonState(event.currentTarget);
        }
      }

      /**
       * toggleButtonState function
       *
       * Toggles the toggle button's state between *pressed* and *not pressed*.
       *
       * @param {HTMLElement} button
       */
      function toggleButtonState(button) {
        const filterSelected = localStorage.getItem('FilterSelected');
        const isAriaPressed = button.getAttribute('aria-pressed') === 'true';
        button.setAttribute('aria-pressed', isAriaPressed ? 'false' : 'true');
        button.innerText = (isAriaPressed === true) ? '♡' : '❤️';
        button.parentElement.classList = (isAriaPressed === true) ? 'all' : 'favorites';
        if (filterSelected === 'favorites' && button.innerText === '♡') {
          filterFavorites();
        }
        populateChannelStorage();
      }

      // Run init function after the DOM content is loaded
      document.addEventListener('DOMContentLoaded',init, false);

      // popstate event listener for when the overlay is displayed and the back button is pressed
      window.addEventListener('popstate', function(event){
        const recentChannel = event.state;
        if (recentChannel === null){
          pausePlayers();
          hideOverlay();
        }
        else {
          switch (recentChannel) {
            case 'dane-reynolds':
              showOverlay(0, 'Dane Reynolds Channel');
              break;
            case 'kelly-slater':
              showOverlay(1, 'Kelly Slater Channel');
              break;
            case 'craig-anderson':
              showOverlay(2, 'Craig Anderson Channel');
              break;
            default:
              showOverlay(0, 'Dane Reynolds Channel');
          }
        }
      }, false); // end popstate listener

      // beforeunload event listener to pause all the players when the user closes the browser (couldn't figure out how to pause player that was playing)
      window.addEventListener('beforeunload', function (e) {
        delete e['returnValue'];
        pausePlayers();
      }, false);

    })();
    </script>

    <!-- For users who have javascript turned off -->
    <noscript>
      <style>
        body {
          margin: 10px;
        }
        main, nav {
          display: none;
        }
        div {
          border: 1px solid black;
          margin: 0 auto;
          max-width: 450px;
          padding: 10px
        }
      </style>
      <div>
        <p>Hey, it looks like you have JavaScript turned off.</p>
        <p>Here's how to <a href="https://www.google.com/search?q=turn+on+javascript">turn on JavaScript</a>.</p>
        <p>If you purposely want it off, this app is very dependent on YouTube which needs JavaScript to run.</p>
        <p>You can just <a href="https://www.youtube.com/channel/UCd1sfSmij8b-w7wP_7IPvSA/playlists?feature=guide&view=1">go to YouTube</a> and check out all our playlists there. Enjoy!<p>
      </div>
    </noscript>

  </body>
</html>
